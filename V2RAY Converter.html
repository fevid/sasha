<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>V2RAY Converter (Vmess Vless Trojan Shadowsocks Wireguard Hysteria2) –¢–µ—Å—Ç–æ–≤—ã–π</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * { font-weight: bold !important; }
    body { background: #121212; color: #eee; font-family: monospace; margin: 0; padding: 10px; display: flex; flex-direction: column; height: 100vh; box-sizing: border-box; }
    h2 { text-align: center; margin: 10px 0 20px; font-size: 1.2em; }
    .container { flex: 1; display: flex; flex-direction: column; gap: 10px; overflow: hidden; }
    .label { color: #bbb; font-size: 0.9em; margin-bottom: 4px; user-select: none; }
    textarea { width: 100%; height: 150px; background: #1e1e1e; color: #eee; padding: 10px; border-radius: 5px; resize: vertical; box-sizing: border-box; font-size: 14px; line-height: 1.3em; border: 3px solid; font-family: monospace; }
    #inputConfig { border-color: #28a745; }
    #outputResult { border-color: #dc3545; }
    .buttons-row { display: flex; width: 100%; gap: 10px; margin-top: 5px; }
    .buttons-left, .buttons-right { display: flex; flex-direction: column; gap: 10px; width: 50%; }
    .clear-row { margin-top: 10px; width: 100%; display: flex; gap: 10px; }
    .clear-row button { flex: 1; color: #fff; padding: 10px 15px; border: none; cursor: pointer; border-radius: 5px; font-size: 12px; user-select: none; white-space: nowrap; transition: filter .2s ease; text-align: center; background: #dc3545; }
    #btnClearInput { border: 5px solid #28a745; }
    #btnClearOutput { border: none; }
    button { color: #fff; padding: 10px 15px; border: none; cursor: pointer; border-radius: 5px; font-size: 14px; user-select: none; white-space: nowrap; transition: filter .2s ease; text-align: center; }
    #btnConvert { background: #28a745; }
    #btnConvertBack { background: #007bff; }
    #btnTextBase64 { background: #ff9800; }
    #btnCopy, #btnDownload { background: #000; border: 2px solid #999; }
    #btnLoadFile { background: #6c757d; }
    button:hover { filter: brightness(1.2); }
    #fileInput { display: none; }
    /* GeoIP –∏ —Ñ–∏–ª—å—Ç—Ä */
    #filterRow { display: flex; flex-direction: column; gap: 5px; margin-bottom: 2px; position: relative; }
    #geoRow { display: flex; align-items: center; gap: 8px; }
    #ipGeoToggle { width: 20px; height: 20px; cursor: pointer; }
    #ipGeoLabel { font-size: 0.9em; margin-left: -7px; color: #bbb; user-select: none; }
    #geoServiceInput { flex: 1; height: 36px; max-width: 190px; padding: 0 10px; font-size: 14px; border: 3px solid #007bff; border-radius: 5px; background: #1e1e1e; color: #eee; box-sizing: border-box; }
    #statusContainer { display: flex; flex-direction: column; align-items: flex-start; color: #00ffee; font-size: 0.9em; }
    .spinner { width: 16px; height: 16px; margin-bottom: 2px; border: 2px solid #0af33; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; display: none; }
    @keyframes spin { to { transform: rotate(360deg); } }
    #controlsRow { display: flex; gap: 7px; align-items: center; }
    #btnCountry { width: 36px; height: 36px; background: #007bff; border-radius: 5px; display: flex; align-items: center; justify-content: center; font-size: 18px; }
  #btnPing { width: 36px; height: 36px; background: #333; border-radius: 5px; display: flex; align-items: center; justify-content: center; font-size: 18px; border: 2px solid #888; }
    #filterInput { flex: 1; height: 36px; padding: 0 10px; font-size: 14px; border: 3px solid #007bff; border-radius: 5px; background: #1e1e1e; color: #eee; box-sizing: border-box; max-width: calc(100% - 160px); }
    #btnSettings { width: 36px; height: 36px; background: #333; border-radius: 5px; display: flex; align-items: center; justify-content: center; font-size: 18px; border: 2px solid #888; }
    #btnFilter { background: #007bff; color: #fff; border: none; border-radius: 5px; padding: 0 15px; font-size: 14px; cursor: pointer; height: 36px; }
    #countryPopup { position: absolute; top: 96px; left: 10px; width: 59vw; max-width: calc(100% - 20px); height: calc(100vh - 210px); background: #1e1e1e; border: 3px solid #007bff; border-radius: 5px; overflow: hidden; display: none; box-sizing: border-box; z-index:100; }
    #countryPopup .search-container { position: sticky; top: 0; background: #1e1e1e; padding: 10px; z-index: 1; box-shadow: 0 2px 4px rgba(0,0,0,0.5); }
    #countryPopup .search-container input { width: calc(100% - 20px); padding: 6px 10px; font-size: 14px; border: 2px solid #007bff; border-radius: 4px; background: #2a2a2a; color: #eee; box-sizing: border-box; }
    #countryPopup .country-list { height: calc(100% - 56px); overflow-y: auto; }
    #countryPopup .country-item { display: flex; align-items: center; padding: 6px 10px; cursor: pointer; }
    #countryPopup .country-item:hover { background: #007bff22; }
    #countryPopup .country-item span { margin-left: 5px; }
    #countryPopup .country-item span:first-child { font-family: "Noto Color Emoji","Apple Color Emoji","Segoe UI Emoji",sans-serif; }
    /* –ú–æ–¥–∞–ª–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫ */
    #settingsModal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 200; }
    #settingsContent { background: #1e1e1e; width: 80vw; max-width: 600px; padding: 20px; border: 3px solid #007bff; border-radius: 5px; position: relative; box-sizing: border-box; padding-bottom: 90px; }
    #settingsContent h3 { margin-top: 0; font-size: 1em; color: #bbb; }
    .settings-row { display: flex; align-items: center; margin-bottom: 15px; gap: 10px; }
    .settings-row input { flex: 1; height: 36px; padding: 0 10px; font-size: 14px; border: 3px solid #28a745; border-radius: 5px; background: #1e1e1e; color: #eee; box-sizing: border-box; }
    .settings-row button { height: 36px; padding: 0 15px; background: #8b0000; border: 2px solid #fff; font-size: 14px; cursor: pointer; }
        #ipWsToggle { position: absolute; left: 20px; bottom: 20px; background: #004b28; border: 2px solid #828282; border-radius: 5px; padding: 5px 10px; font-size: 12px; line-height: 1.2; white-space: normal; display: inline-flex; align-items: center; justify-content: center; height: 36px; }
    #btnDedup { position: absolute; left: 120px; bottom: 20px; background: #004b28; border: 2px solid #828282; border-radius: 5px; padding: 5px 10px; font-size: 12px; line-height: 1.2; white-space: normal; display: inline-flex; align-items: center; justify-content: center; height: 36px; }
    #closeSettings { position: absolute; right: 20px; bottom: 20px; background: #8b0000; color: #fff; border: none; padding: 5px 10px; font-size: 12px; cursor: pointer; }
    @media (max-width:480px) {
      textarea { height: 130px; font-size:13px; }
      .buttons-left button, .buttons-right button, #btnFilter, #btnCountry, #btnPing, #btnSettings, #btnDedup, #ipWsToggle { font-size:13px; padding:8px 12px; }
      #filterInput, #geoServiceInput { font-size:13px; height:32px; }
      #btnCountry, #btnPing, #btnSettings { width:32px; height:32px; }
      #settingsContent { width: 90vw; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4/dist/js-yaml.min.js"></script>
</head>
<body>
  <h1 style="font-size: 15px; text-align: center; margin-top: -8px">V2RAY Converter</h1>
  <h1 style="font-size: 11px; text-align: center; margin-bottom:10px; margin-top:-3px;">(Vmess Vless Trojan Shadowsocks Wireguard Hysteria)</h1>
  <div id="filterRow">
    <div id="geoRow">
      <input type="checkbox" id="ipGeoToggle">
      <label for="ipGeoToggle" id="ipGeoLabel">GeoIP</label>
      <input id="geoServiceInput" type="text" placeholder="https://ipwhois.app/json/{ip}" value="https://ipwhois.app/json/{ip}">
      <div id="statusContainer"><div class="spinner" id="spinner"></div><span id="processStatus"></span></div>
    </div>
    <div class="label">
      <span>–°—Ç—Ä–∞–Ω—ã</span><span style="margin-left:45px;">–§–∏–ª—å—Ç—Ä –ø–æ–∏—Å–∫–∞ / URL-Sub</span>
      <div id="controlsRow">
        <button id="btnCountry">üåé</button>
        <button id="btnPing"><span>pin<br>ger</span></button>
        <input id="filterInput" placeholder="—Ç–µ–∫—Å—Ç, —Ñ–ª–∞–≥, url...">
        <button id="btnSettings">‚öôÔ∏è</button>
        <button id="btnFilter">–æ–∫</button>
      </div>
      <div id="countryPopup"></div>
    </div>
  </div>
  <div class="container">
    <div>
      <div class="label">–ò—Å—Ö–æ–¥–Ω—ã–π JSON, URL, —Ç–µ–∫—Å—Ç</div>
      <textarea id="inputConfig" placeholder="–í—Å—Ç–∞–≤—å json, url, —Ç–µ–∫—Å—Ç..."></textarea>
    </div>
    <div>
      <div class="label">–†–µ–∑—É–ª—å—Ç–∞—Ç</div>
      <textarea id="outputResult" placeholder="–†–µ–∑—É–ª—å—Ç–∞—Ç..."></textarea>
    </div>
    <div class="buttons-row">
      <div class="buttons-left">
        <button id="btnConvert">json ‚Üí url</button>
        <button id="btnConvertBack">url ‚Üí json</button>
        <button id="btnTextBase64">—Ç–µ–∫—Å—Ç ‚Üî base64</button>
      </div>
      <div class="buttons-right">
        <button id="btnCopy">—Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
        <button id="btnDownload">—Å–∫–∞—á–∞—Ç—å</button>
        <button id="btnLoadFile">–∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª</button>
      </div>
    </div>
    <div class="clear-row">
      <button id="btnClearInput">–æ—á–∏—Å—Ç–∏—Ç—å –≤–≤–æ–¥</button>
      <button id="btnClearOutput">–æ—á–∏—Å—Ç–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç</button>
    </div>
  </div>
  <input type="file" id="fileInput" accept=".txt,.json,.yaml,.yml">
  <a id="hiddenDownloadLink" style="display:none;"></a>

  <div id="settingsModal">
    <div id="settingsContent">
      <h3>–ó–∞–º–µ–Ω–∞/–¥–æ–±–∞–≤–ª–µ–Ω–∏–µ Ws-Host</h3>
      <div class="settings-row">
        <input type="text" id="replaceWsHostInput" placeholder="–ù–æ–≤—ã–π ws-host">
        <button id="btnReplaceWsHost">–û–ö</button>
      </div>
      <h3>–ó–∞–º–µ–Ω–∞/–¥–æ–±–∞–≤–ª–µ–Ω–∏–µ SNi</h3>
      <div class="settings-row">
        <input type="text" id="replaceSniInput" placeholder="–ù–æ–≤—ã–π SNi">
        <button id="btnReplaceSni">–û–ö</button>
      </div>
      <h3>–ó–∞–º–µ–Ω–∞/–¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è</h3>
      <div class="settings-row">
        <input type="text" id="replaceNameInput" placeholder="–ù–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ">
        <button id="btnReplaceName">–û–ö</button>
      </div>
      <button id="ipWsToggle">ip‚Üíto<br>ws-host</button>
      <button id="btnDedup">–¥–µ–¥—É–ø–ª<br>–∏–∫–∞—Ü–∏—è</button>
      <button id="closeSettings">–ó–∞–∫—Ä—ã—Ç—å</button>
    </div>
  </div>

  <script>
     
   
   const countries = [
  { flag: 'üåé', name: '–û–¢–ö–õ' },
  { flag: 'üá¶üá´', name: 'Afghanistan' },
  { flag: 'üáøüá¶', name: 'Africa South' },
  { flag: 'üá¶üáΩ', name: 'Aland island' },
  { flag: 'üá¶üá±', name: 'Albania' },
  { flag: 'üá©üáø', name: 'Algeria' },
  { flag: 'üá¶üá∏', name: 'American samoa' },
  { flag: 'üá¶üá©', name: 'Andorra' },
  { flag: 'üá¶üá¥', name: 'Angola' },
  { flag: 'üá¶üáÆ', name: 'Anguilla' },
  { flag: 'üá¶üá¨', name: 'Antigua and barbuda' },
  { flag: 'üá¶üá∂', name: 'Antarctica' },
  { flag: 'üá¶üá∑', name: 'Argentina' },
  { flag: 'üá¶üá≤', name: 'Armenia' },
  { flag: 'üá¶üáº', name: 'Aruba' },
  { flag: 'üá¶üá®', name: 'Ascension island' },
  { flag: 'üá¶üá∫', name: 'Australia' },
  { flag: 'üá¶üáπ', name: 'Austria' },
  { flag: 'üá¶üáø', name: 'Azerbaijan' },
  { flag: 'üáßüá∏', name: 'Bahamas' },
  { flag: 'üáßüá≠', name: 'Bahrain' },
  { flag: 'üáßüá©', name: 'Bangladesh' },
  { flag: 'üáßüáß', name: 'Barbados' },
  { flag: 'üáßüáæ', name: 'Belarus' },
  { flag: 'üáßüá™', name: 'Belgium' },
  { flag: 'üáßüáø', name: 'Belize' },
  { flag: 'üáßüáØ', name: 'Benin' },
  { flag: 'üáßüá≤', name: 'Bermuda' },
  { flag: 'üáßüáπ', name: 'Bhutan' },
  { flag: 'üáßüá¥', name: 'Bolivia (plurinational state of)' },
  { flag: 'üáßüá¶', name: 'Bosnia and herzegovina' },
  { flag: 'üáßüáª', name: 'Bouvet island' },
  { flag: 'üáßüáº', name: 'Botswana' },
  { flag: 'üáßüá∑', name: 'Brazil' },
  { flag: 'üáÆüá¥', name: 'British indian ocean territory' },
  { flag: 'üáßüá≥', name: 'Brunei darussalam' },
  { flag: 'üáßüá¨', name: 'Bulgaria' },
  { flag: 'üáßüá´', name: 'Burkina faso' },
  { flag: 'üáßüáÆ', name: 'Burundi' },
  { flag: 'üá≥üá®', name: 'Caledonia new' },
  { flag: 'üá∞üá≠', name: 'Cambodia' },
  { flag: 'üá®üá≤', name: 'Cameroon' },
  { flag: 'üá®üá¶', name: 'Canada' },
  { flag: 'üáÆüá®', name: 'Canary islands' },
  { flag: 'üá®üáª', name: 'Cape verde' },
 { flag: 'üáßüá∂', name: 'Caribbean Netherlands (Bonaire, Sint‚ÄØEustatius & Saba)' },
  { flag: 'üá®üá´', name: 'Central african republic' },
  { flag: 'üáπüá©', name: 'Chad' },
  { flag: 'üá®üá±', name: 'Chile' },
  { flag: 'üá®üá≥', name: 'China' },
  { flag: 'üá®üáΩ', name: 'Christmas island' },
  { flag: 'üá®üáµ', name: 'Clipperton island' },
  { flag: 'üá®üá®', name: 'Cocos (keeling) islands' },
  { flag: 'üá®üá¥', name: 'Colombia' },
  { flag: 'üá∞üá≤', name: 'Comoros' },
  { flag: 'üá®üá¨', name: 'Congo' },
  { flag: 'üá®üá©', name: 'Congo, the democratic republic of the' },
  { flag: 'üá®üá∞', name: 'Cook islands' },
  { flag: 'üá®üá∑', name: 'Costa rica' },
  { flag: 'üá®üáÆ', name: 'Cote d`ivoire' },
  { flag: 'üá≠üá∑', name: 'Croatia' },
  { flag: 'üá®üá∫', name: 'Cuba' },
  { flag: 'üá®üáº', name: 'Cura√ßao' },
  { flag: 'üá®üáæ', name: 'Cyprus' },
  { flag: 'üá®üáø', name: 'Czechia' },
  { flag: 'üá©üá∞', name: 'Denmark' },
  { flag: 'üá©üá¨', name: 'Diego garcia' },
  { flag: 'üá©üáØ', name: 'Djibouti' },
  { flag: 'üá©üá≤', name: 'Dominica' },
  { flag: 'üá©üá¥', name: 'Dominican republic' },
  { flag: 'üá™üá®', name: 'Ecuador' },
  { flag: 'üá™üá™', name: 'Estonia' },
  { flag: 'üá™üá¨', name: 'Egypt' },
  { flag: 'üá∏üáª', name: 'El salvador' },
  { flag: 'üá¨üá∂', name: 'Equatorial guinea' },
  { flag: 'üá™üá∑', name: 'Eritrea' },
  { flag: 'üá™üáπ', name: 'Ethiopia' },
  { flag: 'üá™üá∫', name: 'European union' },
  { flag: 'üá´üá∞', name: 'Falkland islands (malvinas)' },
  { flag: 'üá´üá¥', name: 'Faroe islands' },
  { flag: 'üá´üáØ', name: 'Fiji' },
  { flag: 'üá´üáÆ', name: 'Finland' },
  { flag: 'üá´üá∑', name: 'France' },
  { flag: 'üá¨üá´', name: 'French guiana' },
  { flag: 'üáµüá´', name: 'French polynesia' },
  { flag: 'üáπüá´', name: 'French southern territories' },
  { flag: 'üá¨üá¶', name: 'Gabon' },
  { flag: 'üá¨üá≤', name: 'Gambia' },
  { flag: 'üá¨üá™', name: 'Georgia' },
  { flag: 'üá¨üá∏', name: 'Georgia South, and south sandwich islands' },
  { flag: 'üá©üá™', name: 'Germany' },
  { flag: 'üá¨üá≠', name: 'Ghana' },
  { flag: 'üá¨üáÆ', name: 'Gibraltar' },
  { flag: 'üá¨üá∑', name: 'Greece' },
  { flag: 'üá¨üá±', name: 'Greenland' },
  { flag: 'üá¨üá©', name: 'Grenada' },
  { flag: 'üá¨üáµ', name: 'Guadeloupe' },
  { flag: 'üá¨üá∫', name: 'Guam' },
  { flag: 'üá¨üáº', name: 'Guinea-bissau' },
  { flag: 'üá¨üá≥', name: 'Guinea' },
  { flag: 'üá¨üáæ', name: 'Guyana' },
  { flag: 'üá≠üáπ', name: 'Haiti' },
 { flag: 'üá≠üá≤', name: 'Heard island and mcdonald islands' },
  { flag: 'üá≠üá∞', name: 'Hong kong' },
   { flag: 'üá≠üá≥', name: 'Honduras' },
  { flag: 'üá≠üá∫', name: 'Hungary' },
  { flag: 'üáÆüá∏', name: 'Iceland' },
  { flag: 'üáÆüá≥', name: 'India' },
  { flag: 'üáÆüá©', name: 'Indonesia' },
  { flag: 'üáÆüá™', name: 'Ireland' },
  { flag: 'üáÆüá±', name: 'Israel' },
  { flag: 'üáÆüá≤', name: 'Isle of man' },
  { flag: 'üáÆüá∂', name: 'Iraq' },
  { flag: 'üáÆüá∑', name: 'Iran (islamic republic of)' },
  { flag: 'üáÆüáπ', name: 'Italy' },
  { flag: 'üáØüá™', name: 'Jersey' },
  { flag: 'üáØüá≤', name: 'Jamaica' },
  { flag: 'üáØüá¥', name: 'Jordan' },
  { flag: 'üáØüáµ', name: 'Japan' },
  { flag: 'üá∞üá™', name: 'Kenya' },
  { flag: 'üá∞üáÆ', name: 'Kiribati' },
{ flag: 'üá∞üá∑', name: 'Korea South' },
  { flag: 'üá∞üáµ', name: 'Korea North' },
  { flag: 'üáΩüá∞', name: 'Kosovo' },
  { flag: 'üá∞üáº', name: 'Kuwait' },
  { flag: 'üá∞üáø', name: 'Kazakhstan' },
  { flag: 'üá±üá¶', name: 'Lao people‚Äôs democratic republic' },
  { flag: 'üá±üáª', name: 'Latvia' },
  { flag: 'üá±üáß', name: 'Lebanon' },
 { flag: 'üá±üá∏', name: 'Lesotho' },
  { flag: 'üá±üá∑', name: 'Liberia' }, 
  { flag: 'üá±üáæ', name: 'Libya' },
  { flag: 'üá±üáÆ', name: 'Liechtenstein' },
  { flag: 'üá±üáπ', name: 'Lithuania' },
  { flag: 'üá±üá∫', name: 'Luxembourg' },
  { flag: 'üá≤üá¥', name: 'Macao, region of china' },
 { flag: 'üá≤üá∞', name: 'Macedonia North' },
  { flag: 'üá≤üá¨', name: 'Madagascar' },
  { flag: 'üá≤üáæ', name: 'Malaysia' },
  { flag: 'üá≤üá±', name: 'Mali' },
  { flag: 'üá≤üáπ', name: 'Malta' },
  { flag: 'üá≤üáª', name: 'Maldives' },
  { flag: 'üá≤üáº', name: 'Malawi' },
  { flag: 'üá≤üá≠', name: 'Marshall islands' },
  { flag: 'üá≤üá∂', name: 'Martinique' },
 { flag: 'üá≤üá∑', name: 'Mauritania' },
  { flag: 'üá≤üá∫', name: 'Mauritius' },
  { flag: 'üáæüáπ', name: 'Mayotte' },
 { flag: 'üá≤üáΩ', name: 'Mexico' },
 { flag: 'üá≤üá©', name: 'Moldova, republic of' }, 
  { flag: 'üá≤üá®', name: 'Monaco' },
  { flag: 'üá≤üá≥', name: 'Mongolia' },
  { flag: 'üá≤üá™', name: 'Montenegro' },
  { flag: 'üá≤üá∏', name: 'Montserrat' },
  { flag: 'üá≤üá¶', name: 'Morocco' },
  { flag: 'üá≤üáø', name: 'Mozambique' },
 { flag: 'üá≤üá≤', name: 'Myanmar' },
  { flag: 'üá≥üá¶', name: 'Namibia' },
  { flag: 'üá≥üá∑', name: 'Nauru' },
  { flag: 'üá≥üáµ', name: 'Nepal' }, 
  { flag: 'üá≥üá±', name: 'Netherlands' },
  { flag: 'üá≥üá®', name: 'New caledonia' },
 { flag: 'üá≥üáø', name: 'New zealand' },
  { flag: 'üá≥üáÆ', name: 'Nicaragua' },
  { flag: 'üá≥üá™', name: 'Niger' },
  { flag: 'üá≥üá¨', name: 'Nigeria' },
  { flag: 'üá≥üá∫', name: 'Niue' },
  { flag: 'üá≥üá´', name: 'Norfolk island' },
  { flag: 'üá≤üáµ', name: 'Northern mariana islands' },
 { flag: 'üá≥üá¥', name: 'Norway' },
  { flag: 'üá¥üá≤', name: 'Oman' },
  { flag: 'üáµüá∞', name: 'Pakistan' },
  { flag: 'üáµüáº', name: 'Palau' },
  { flag: 'üáµüá∏', name: 'Palestine, state of' },
  { flag: 'üáµüá¶', name: 'Panama' },
  { flag: 'üáµüá¨', name: 'Papua new guinea' },
  { flag: 'üáµüáæ', name: 'Paraguay' },
  { flag: 'üáµüá™', name: 'Peru' },
 { flag: 'üáµüá≠', name: 'Philippines' },
  { flag: 'üáµüá≥', name: 'Pitcairn' },
  { flag: 'üáµüá´', name: 'Polynesia French' },
 { flag: 'üáµüá±', name: 'Poland' },
  { flag: 'üáµüáπ', name: 'Portugal' },
{ flag: 'üáµüá∑', name: 'Puerto rico' },
  { flag: 'üá∂üá¶', name: 'Qatar' },
  { flag: 'üá∑üá™', name: 'R√©union' },
  { flag: 'üá∑üá¥', name: 'Romania' },
  { flag: 'üá∑üá∫', name: 'Russian federation' },
  { flag: 'üá∑üáº', name: 'Rwanda' },
  { flag: 'üá™üá≠', name: 'Sahara Western' },
  { flag: 'üá±üá®', name: 'Saint lucia' },
  { flag: 'üá≤üá´', name: 'Saint martin (french part)' },
  { flag: 'üáµüá≤', name: 'Saint pierre and miquelon' },
 { flag: 'üá∏üá≠', name: 'Saint helena, ascension and tristan da cunha' },
  { flag: 'üáªüá®', name: 'Saint vincent and the grenadines' },
  { flag: 'üáºüá∏', name: 'Samoa' },
  { flag: 'üá∏üá≤', name: 'San marino' },
  { flag: 'üá∏üá¶', name: 'Saudi arabia' },
  { flag: 'üá∏üá≥', name: 'Senegal' },
  { flag: 'üá∑üá∏', name: 'Serbia' },
  { flag: 'üá∏üá®', name: 'Seychelles' },
  { flag: 'üá∏üá±', name: 'Sierra leone' },
  { flag: 'üá∏üá¨', name: 'Singapore' },
  { flag: 'üá∏üáΩ', name: 'Sint maarten (dutch part)' },
  { flag: 'üá∏üá∞', name: 'Slovakia' },
  { flag: 'üá∏üáÆ', name: 'Slovenia' },
  { flag: 'üá∏üáß', name: 'Solomon islands' },
  { flag: 'üá∏üá©', name: 'Sudan' },
  { flag: 'üá∏üáØ', name: 'Svalbard and jan mayen' },
  { flag: 'üá∏üá™', name: 'Sweden' },
  { flag: 'üá∏üá¥', name: 'Somalia' },
  { flag: 'üá∏üá∑', name: 'Suriname' },
  { flag: 'üá™üá¶', name: 'Spain' },
  { flag: 'üá™üá∏', name: 'Spain' },
  { flag: 'üá±üá∞', name: 'Sri lanka' },
  { flag: 'üá∏üá∏', name: 'Sudan South' },
  { flag: 'üáπüáº', name: 'Taiwan' },
  { flag: 'üáπüáØ', name: 'Tajikistan' },
  { flag: 'üáπüáø', name: 'Tanzania, united republic of' },
  { flag: 'üáπüá≠', name: 'Thailand' },
  { flag: 'üáπüá±', name: 'Timor-leste' },
{ flag: 'üáπüá¨', name: 'Togo' },
  { flag: 'üáπüá∞', name: 'Tokelau' },
  { flag: 'üáπüá¥', name: 'Tonga' },
  { flag: 'üáπüáπ', name: 'Trinidad and tobago' },
  { flag: 'üáπüá¶', name: 'Tristan da cunha' },
  { flag: 'üáπüá≥', name: 'Tunisia' },
  { flag: 'üáπüá®', name: 'Turks and caicos islands' },
  { flag: 'üáπüá≤', name: 'Turkmenistan' },
  { flag: 'üáπüá∑', name: 'Turkey' },
  { flag: 'üáπüáª', name: 'Tuvalu' },
  { flag: 'üá∫üá¨', name: 'Uganda' },
  { flag: 'üá∫üá¶', name: 'Ukraine' },
  { flag: 'üá¶üá™', name: 'United arab emirates' },
  { flag: 'üá¨üáß', name: 'United kingdom' },
  { flag: 'üá∫üá≥', name: 'United nations' },
  { flag: 'üá∫üá∏', name: 'United States' },
  { flag: 'üá∫üáæ', name: 'Uruguay' },
  { flag: 'üá∫üáø', name: 'Uzbekistan' },
  { flag: 'üáªüá∫', name: 'Vanuatu' },
  { flag: 'üáªüá¶', name: 'Vatican city' },
  { flag: 'üáªüá™', name: 'Venezuela (bolivarian republic of)' },
  { flag: 'üáªüá≥', name: 'Vietnam' },
  { flag: 'üáªüá¨', name: 'Virgin islands (british)' },
  { flag: 'üáªüáÆ', name: 'Virgin islands (u.s.)' },
  { flag: 'üáºüá´', name: 'Wallis and futuna' },
  { flag: 'üáæüá™', name: 'Yemen' },
  { flag: 'üáøüá≤', name: 'Zambia' },
  { flag: 'üáøüáº', name: 'Zimbabwe' },
  
  ];  
     
     
function parseWireguardToIni(line) {
  try {
    const u = new URL(line);
    const p = u.searchParams;
    const priv = decodeURIComponent(u.username);
    const [host, port] = u.host.split(':');
    const address = p.get('address') || '';
    const psk     = p.get('presharedkey') || '';
    const pub     = p.get('publickey')    || '';
    const mtu     = p.get('mtu')          || '1420';

    return [
      '[Interface]',
      `PrivateKey = ${priv}`,
      `Address = ${address}`,
      `MTU = ${mtu}`,
      '',
      '[Peer]',
      `PublicKey = ${pub}`,
      `PresharedKey = ${psk}`,
      `Endpoint = ${host}:${port}`,
      `PersistentKeepalive = 25`
    ].join('\n');
  } catch {
    return '';
  }
}

function parseIniToWireguard(block) {
  try {
    const lines = block.split(/\r?\n/);
    const map = {};
    lines.forEach(l => {
      const [k, v] = l.split('=').map(s => s.trim());
      if (k && v !== undefined) map[k] = v;
    });
    const url = new URL(`wireguard://${encodeURIComponent(map['PrivateKey'])}@${map['Endpoint']}`);
    url.searchParams.set('address', map['Address'] || '');
    url.searchParams.set('presharedkey', map['PresharedKey'] || '');
    url.searchParams.set('publickey', map['PublicKey'] || '');
    url.searchParams.set('mtu', map['MTU'] || '1420');
    url.searchParams.set('reserved', '0,0,0');
    return url.toString();
  } catch {
    return '';
  }
}
    function extractAllJSON(text) {
      const res = [], stack = [], starts = [];
      for (let i = 0; i < text.length; i++) {
        if (text[i] === '{') { if (!stack.length) starts.push(i); stack.push('{'); }
        else if (text[i] === '}') {
          stack.pop();
          if (!stack.length && starts.length) {
            const start = starts.pop();
            try { res.push(JSON.parse(text.slice(start, i + 1))); } catch {}
          }
        }
      }
      return res;
    }

    function countryCodeToFlag(cc) {
      return cc.toUpperCase().replace(/./g, c => String.fromCodePoint(0x1F1E6 + c.charCodeAt(0) - 65));
    }

    function buildGeoUrl(host) {
      const tpl = document.getElementById('geoServiceInput').value.trim().replace(/\/+$/, '');
      if (tpl.includes('{ip}')) return tpl.replace(/{ip}/g, host);
      if (tpl.includes('?')) return `${tpl}&ip=${host}`;
      return `${tpl}/${host}`;
    }

    function buildURLFromLegacy(o, urls) {
      const p = new URLSearchParams();
      p.set('security', o.method || 'none');
      p.set('type', o.network || '');
      if (o.headerType) p.set('headerType', o.headerType);
      if (o.host) p.set('host', o.host);
      if (o.sni) p.set('sni', o.sni);
      if (o.path) p.set('path', o.path);
      if (o.alpn) p.set('alpn', Array.isArray(o.alpn) ? o.alpn.join(',') : o.alpn);
      if (o.pbk) p.set('pbk', o.pbk);
      if (o.sid) p.set('sid', o.sid);
      if (o.flow) p.set('flow', o.flow);
      if (o.seed) p.set('seed', o.seed);
      if (o.serviceName) p.set('serviceName', o.serviceName);
      p.set('allowInsecure', o.insecure ? '1' : '0');
      const tag = encodeURIComponent(o.remarks || o.customConfig?.name || '');
      const base = `vless://${o.password}@${o.server}:${o.serverPort}`;
      urls.push(`${base}?${p.toString()}#${tag}`);
    }

    function buildURLsFromOutboundBean(obj, urls) {
      buildURLFromOutbound(obj.outboundBean, obj.remarks, urls);
    }

    function buildURLsFromCustomJSON(obj, urls) {
      obj.custom_json.outbounds.forEach(o => buildURLFromOutbound(o, obj.remarks, urls));
    }

    function buildURLFromOutbound(o, remarks, urls) {
      const proto = o.protocol;
      const tag = encodeURIComponent(remarks || o.tag || proto);
      const p = new URLSearchParams();
      let base = '';

      if (proto === 'shadowsocks') {
        (o.settings.servers || []).forEach(s => {
          const a = btoa(`${s.method}:${s.password}`).replace(/=+$/, '');
          urls.push(`ss://${a}@${s.address}:${s.port}#${tag}`);
        });
        return;
      }

      if (proto === 'vmess' || proto === 'vless') {
        const v = o.settings.vnext?.[0];
        const u = v?.users?.[0];
        if (v && u) {
          base = `${proto}://${u.id}@${v.address}:${v.port}`;
          p.set('encryption', u.encryption || u.security || (proto === 'vmess' ? 'auto' : 'none'));
          if (u.flow) p.set('flow', u.flow);
        }
      }

      if (proto === 'trojan') {
        const s = o.settings.servers?.[0];
        if (s) {
          base = `trojan://${encodeURIComponent(s.password)}@${s.address}:${s.port}`;
        }
      }

      if (proto === 'wireguard') {
        const s    = o.settings;
        const peer = s.peers?.[0];
        if (s && peer) {
          const url = new URL(`wireguard://${peer.endpoint}`);
          url.username = s.secretKey;
          url.searchParams.set('address', s.address?.[0] || '');
          url.searchParams.set('presharedkey', peer.preSharedKey);
          url.searchParams.set('publickey', peer.publicKey);
          url.searchParams.set('mtu', s.mtu || 1420);
          url.searchParams.set('reserved', '0,0,0');
          urls.push(url.toString());
        }
        return;
      }

      if (proto === 'hysteria2') {
        const srv = o.settings.servers?.[0];
        const hy = o.streamSettings.hy2Settings;
        if (srv && hy) {
          base = `hysteria2://${encodeURIComponent(hy.password)}@${srv.address}:${srv.port}`;
          if (hy.use_udp_extension) p.set('insecure', '1');
          if (o.streamSettings.tlsSettings.allowInsecure) p.set('insecure', '1');
          if (o.streamSettings.tlsSettings.serverName) p.set('sni', o.streamSettings.tlsSettings.serverName);
        }
      }

      if (!base) return;

      const st = o.streamSettings || {};
      const tls = st.tlsSettings || {};
      const rel = st.realitySettings || {};

      if (st.security) p.set('security', st.security);
      if (tls.allowInsecure) p.set('allowInsecure', '1');
      if (Array.isArray(tls.alpn)) p.set('alpn', tls.alpn.join(','));
      if (tls.serverName) p.set('sni', tls.serverName);
      else if (rel.serverName) p.set('sni', rel.serverName);
      if (tls.fingerprint) p.set('fp', tls.fingerprint);
      if (rel.publicKey) p.set('pbk', rel.publicKey);
      if (rel.shortId) p.set('sid', rel.shortId);
      if (st.grpcSettings?.serviceName) p.set('serviceName', st.grpcSettings.serviceName);
      if (st.kcpSettings?.seed) p.set('seed', st.kcpSettings.seed);

      let net = st.network || '';
      if (!net) {
        if (st.wsSettings) net = 'ws';
        else if (st.httpupgradeSettings) net = 'httpupgrade';
        else if (st.splithttpSettings) net = 'splithttp';
        else if (st.httpSettings) net = 'http';
        else net = 'tcp';
      }
      if (net === 'splithttp') net = 'xhttp';
      p.set('type', net);

      let host = '';
      let path = '';
      if (net === 'ws' && st.wsSettings) {
        host = st.wsSettings.headers?.Host || '';
        path = st.wsSettings.path || '';
      } else if (net === 'xhttp' && st.splithttpSettings) {
        host = st.splithttpSettings.host || '';
        path = st.splithttpSettings.path || '';
      } else if (net === 'httpupgrade' && st.httpupgradeSettings) {
        host = Array.isArray(st.httpupgradeSettings.host) ? st.httpupgradeSettings.host[0] : st.httpupgradeSettings.host || '';
        path = st.httpupgradeSettings.path || '';
      } else if (net === 'http' && st.httpSettings) {
        host = Array.isArray(st.httpSettings.host) ? st.httpSettings.host[0] : st.httpSettings.host || '';
        path = st.httpSettings.path || '';
      } else if (net === 'tcp' && st.tcpSettings?.header?.type === 'http') {
        const rq = st.tcpSettings.header.request;
        host = (rq.headers?.Host || [''])[0] || '';
        path = (rq.path || [''])[0] || '';
        p.set('headerType', 'http');
      }

      if (host) p.set('host', host);
      if (path) p.set('path', path);

      urls.push(`${base}?${p.toString()}#${tag}`);
    }

    function decodeVmessBase64(line) {
      try {
        const b64 = line.replace(/^vmess:\/\//, '').trim();
        const raw = atob(b64);
        let str;
        try {
          str = decodeURIComponent(escape(raw));
        } catch (e) {
          str = raw;
        }
        const json = JSON.parse(str);
        const ps = json.ps || '';
        const add = json.add;
        const port = json.port;
        const id = json.id;
        const params = new URLSearchParams();
        if (json.security)     params.set('security', json.security);
        if (json.encryption)   params.set('encryption', json.encryption);
        if (json.net)          params.set('type', json.net);
        if (json.type)         params.set('headerType', json.type);
        if (json.host)         params.set('host', json.host);
        if (json.path)         params.set('path', json.path);
        if (json.sni)          params.set('sni', json.sni);
        if (json.fingerprint)  params.set('fp', json.fingerprint);
        if (json.alpn)         params.set('alpn', Array.isArray(json.alpn) ? json.alpn.join(',') : json.alpn);
        if (json.flow)         params.set('flow', json.flow);
        if (json.pbk)          params.set('pbk', json.pbk);
        if (json.sid)          params.set('sid', json.sid);
        if (json.seed)         params.set('seed', json.seed);
        if (json.serviceName)  params.set('serviceName', json.serviceName);
        if (json.allowInsecure)params.set('allowInsecure', json.allowInsecure ? '1' : '0');
        return (`vmess://${id}@${add}:${port}${params.toString() ? '?' + params.toString() : ''}#${ps}`)
               .replace(/%2F/g,'/')
               .replace(/%2B/g,'+');
      } catch (e) {
        return line;
      }
    }

    function parseWireguardURL(l) {
      const u = new URL(l);
      const secretKeyRaw = decodeURIComponent(u.username);
      const endpoint = u.host;
      const params = u.searchParams;
      const address = params.get('address') || '';
      const presharedKey = params.get('presharedkey') || '';
      const publicKey = params.get('publickey') || '';
      const mtu = parseInt(params.get('mtu'), 10) || 1420;

      return {
        protocol: 'wireguard',
        tag: u.hash ? decodeURIComponent(u.hash.slice(1)) : 'wireguard',
        settings: {
          address: [ decodeURIComponent(address) ],
          mtu,
          secretKey: secretKeyRaw,
          peers: [{
            endpoint,
            keepAlive: 25,
            preSharedKey: presharedKey,
            publicKey
          }]
        }
      };
    }

    function handleSpecialJunkConfig(obj, urls) {
      if (!obj.config || typeof obj.config !== 'string') return false;
      try {
        const cfg = JSON.parse(obj.config), rootAddress = obj.address || '', rootId = obj.server_id || '';
        if (Array.isArray(cfg.outbounds)) {
          cfg.outbounds.forEach(o => {
            if (o.settings?.vnext?.[0] && !o.settings.vnext[0].address && rootAddress) o.settings.vnext[0].address = rootAddress;
            if (o.settings?.vnext?.[0]?.users?.[0] && !o.settings.vnext[0].users[0].id && rootId) o.settings.vnext[0].users[0].id = rootId;
            if (o.streamSettings?.realitySettings && cfg.outbounds[0].streamSettings?.realitySettings?.spiderX) o.streamSettings.realitySettings.spiderX = cfg.outbounds[0].streamSettings.realitySettings.spiderX;
            buildURLFromOutbound(o, obj.remarks, urls);
          });
          return true;
        }
      } catch {}
      return false;
    }

    function handleJunkConfig(obj, urls) {
      if (obj.configType === 'SHADOWSOCKS' && obj.method && obj.password && obj.server && obj.serverPort) {
        const a = btoa(`${obj.method}:${obj.password}`).replace(/=+$/, ''), tag = encodeURIComponent(obj.remarks || '');
        urls.push(`ss://${a}@${obj.server}:${obj.serverPort}#${tag}`);
        return true;
      }
      if (obj.configType === 'VLESS' && obj.password && obj.server && obj.serverPort) {
        const params = new URLSearchParams();
        params.set('encryption', obj.method || 'none');
        params.set('security', obj.security || '');
        if (obj.flow) params.set('flow', obj.flow);
        if (obj.network) params.set('type', obj.network);
        if (obj.headerType) params.set('headerType', obj.headerType);
        if (obj.host) params.set('host', obj.host);
        if (obj.path) params.set('path', obj.path);
        if (obj.sni) params.set('sni', obj.sni);
        if (obj.fingerPrint) params.set('fp', obj.fingerPrint);
        if (obj.alpn) params.set('alpn', Array.isArray(obj.alpn) ? obj.alpn.join(',') : obj.alpn);
        if (obj.publicKey) params.set('pbk', obj.publicKey);
        if (obj.shortId) params.set('sid', obj.shortId);
        if (obj.allowInsecure !== undefined) params.set('allowInsecure', obj.allowInsecure ? '1' : '0');
        const tag = encodeURIComponent(obj.remarks || '');
        urls.push(`vless://${obj.password}@${obj.server}:${obj.serverPort}?${params.toString()}#${tag}`);
        return true;
      }
      return false;
    }


    document.addEventListener('DOMContentLoaded', () => {
      const inEl = document.getElementById('inputConfig'),
            outEl = document.getElementById('outputResult'),
            filterInput = document.getElementById('filterInput'),
            btnFilter = document.getElementById('btnFilter'),
            ipGeoToggle = document.getElementById('ipGeoToggle'),
            spinner = document.getElementById('spinner'),
            statusEl = document.getElementById('processStatus'),
            btnCountry = document.getElementById('btnCountry'),
            btnPing = document.getElementById('btnPing'),
            countryPopup = document.getElementById('countryPopup'),
            fileInput = document.getElementById('fileInput'),
            hiddenDownloadLink = document.getElementById('hiddenDownloadLink'),
            btnSettingsLocal = document.getElementById('btnSettings'),
            settingsModalLocal = document.getElementById('settingsModal'),
            closeSettingsLocal = document.getElementById('closeSettings'),
            btnClearInput = document.getElementById('btnClearInput'),
            btnClearOutput = document.getElementById('btnClearOutput');

      let selectedCountry = 'OFF';
      let ipWsToggled = false;

      function initCountryPopup() {
        countryPopup.innerHTML = '';
        const container = document.createElement('div');
        container.className = 'search-container';
        const searchEl = document.createElement('input');
        searchEl.type = 'text';
        searchEl.placeholder = '–ü–æ–∏—Å–∫‚Ä¶';
        container.appendChild(searchEl);
        countryPopup.appendChild(container);
        const listEl = document.createElement('div');
        listEl.className = 'country-list';
        countryPopup.appendChild(listEl);
        searchEl.addEventListener('input', () => filterCountries(searchEl.value, listEl));
        filterCountries('', listEl);
      }

      function filterCountries(term, listEl) {
        const lower = term.toLowerCase();
        listEl.innerHTML = '';
        countries.forEach(c => {
          const matchName = !lower || c.name.toLowerCase().startsWith(lower);
          const matchFlag = term.includes(c.flag);
          if (matchName || matchFlag) {
            const item = document.createElement('div');
            item.className = 'country-item';
            item.innerHTML = `<span>${c.flag}</span><span>${c.name}</span>`;
            item.onclick = () => {
              selectedCountry = c.flag;
              btnCountry.textContent = c.flag;
              countryPopup.style.display = 'none';
            };
            listEl.appendChild(item);
          }
        });
      }

      btnCountry.addEventListener('click', e => {
        e.stopPropagation();
        countryPopup.style.display = countryPopup.style.display === 'block' ? 'none' : 'block';
        if (countryPopup.style.display === 'block') initCountryPopup();
      });
      document.addEventListener('click', () => {
        if (countryPopup.style.display === 'block') countryPopup.style.display = 'none';
      });
      countryPopup.addEventListener('click', e => e.stopPropagation());

      function setStatus(html, spinning) {
        statusEl.innerHTML = html;
        spinner.style.display = spinning ? 'inline-block' : 'none';
      }

      
const tcpBaseline = 99;
const httpBaseline = 999;
const httpFactor = tcpBaseline / httpBaseline;

async function pingHost(host) {
  const timeoutMs = 5000;
  const start = performance.now();
  const proto = location.protocol === 'https:' ? 'https:' : 'http:';
  try {
    await Promise.race([
      fetch(`${proto}//${host}`, { mode: 'no-cors' }),
      new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), timeoutMs))
    ]);
    const duration = Math.round(performance.now() - start);
    const adjusted = Math.round(duration * httpFactor);
    return { host, time: adjusted, status: `üîò ${adjusted}ms` };
  } catch {
    return { host, time: Infinity, status: '‚ùå —Ç–∞–π–º-–∞—É—Ç' };
  }
}

let pinging = false, resultsPing = [];
async function pingAll() {
  pinging = true;
  resultsPing = [];
  // ... –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ ...

        const lines = inEl.value.split(/\r?\n/).filter(Boolean), total = lines.length;
        for (let i = 0; i < total; i++) {
          if (!pinging) break;
          let host;
          try { host = new URL(lines[i]).hostname; }
          catch { const m = lines[i].match(/\/\/([^\/:]+)/); host = m ? m[1] : lines[i]; }
          const res = await pingHost(host);
          resultsPing.push({ ...res, original: lines[i] });
          setStatus(`–ø–∏–Ω–≥‚Ä¶ ${Math.round(resultsPing.length / total * 100)}%`, true);
          const sorted = resultsPing.slice().sort((a, b) => a.time - b.time);
          outEl.value = sorted.map(r => `${r.original} ${r.status}`).join('\n');
        }
        setStatus('–≥–æ—Ç–æ–≤–æ!', false); pinging = false;
      }

      btnPing.onclick = () => pinging ? (pinging = false, setStatus('', false)) : pingAll();

      btnFilter.onclick = async () => {
        const raw = inEl.value.trim(),
              filterVal = filterInput.value.trim();

    
    if (filterInput.value.trim().match(/^https?:\/\//)) {
          const urls = filterInput.value.trim().split(/\s+/);
          const downloaded = [];
          setStatus('–∑–∞–≥—Ä—É–∑–∫–∞...<br>0%', true);
          for (let i = 0; i < urls.length; i++) {
            let txt = '';
            try {
              const resp = await fetch(urls[i]);
              txt = resp.ok ? await resp.text() : '';
            } catch {
              const proxy = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(urls[i]);
              const resp2 = await fetch(proxy);
              txt = resp2.ok ? await resp2.text() : '';
            }
            const b64 = txt.trim().replace(/\s+/g, '');
            if (/^[A-Za-z0-9+/=]+$/.test(b64) && b64.length % 4 === 0) {
              try { txt = atob(b64); } catch {}
            }
            downloaded.push(txt);
            setStatus(`–∑–∞–≥—Ä—É–∑–∫–∞...<br>${Math.round((i+1)/urls.length*100)}%`, true);
          }
          inEl.value = downloaded.join('\n');
          setStatus('–≥–æ—Ç–æ–≤–æ!', false);
          return;
        }

        
      btnFilter.disabled = true; setStatus('–∑–∞–ø—É—Å–∫...<br>0%', true);
        const rawLines = inEl.value.split(/\r?\n/).filter(Boolean), results = [];

        if (ipGeoToggle.checked) {
          const seen = {};
          for (let i = 0; i < rawLines.length; i++) {
            const line = rawLines[i].trim();
            let host;
            try { host = new URL(line).hostname; }
            catch { host = (line.match(/\/\/([^\/:]+)/) || [])[1] || line; }
            if (!seen[host]) {
              try {
                const res = await fetch(buildGeoUrl(host));
                const d = await res.json();
                const code = (d.country_code || d.countryCode || d.code || d.geoplugin_countryCode || d.country || '').toUpperCase();
                let name = d.country_name || d.countryName || d.geoplugin_countryName || d.country || host;
                if (code) {
                  const isShort = name.length <= 3 || name.toUpperCase() === code;
                  if (isShort) {
                    const flag = countryCodeToFlag(code);
                    const entry = countries.find(c => c.flag === flag);
                    if (entry) name = entry.name;
                  }
                  seen[host] = `${countryCodeToFlag(code)} ${name}`;
                } else {
                  seen[host] = host;
                }
              } catch {
                seen[host] = host;
              }
            }
            results.push(`${line.split('#')[0]}#${seen[host]}`);
            setStatus(`–æ–±—Ä–∞–±–æ—Ç–∫–∞...<br>${Math.round((i + 1) / rawLines.length * 100)}%`, true);
          }
        } else {
          for (let i = 0; i < rawLines.length; i++) {
            const line = rawLines[i].trim();
            let decoded;

            if (line.startsWith('vmess://')) {
              decoded = decodeVmessBase64(line);
            } else {
              try {
                decoded = decodeURIComponent(line);
              } catch {
                decoded = line;
              }
            }

if (line.startsWith('vmess://')) {
  const tmp = decodeVmessBase64(line);
  try {
    decoded = decodeURIComponent(tmp);
  } catch {
    decoded = tmp;
  }
} else {
  // ‚Ä¶ –≤–∞—à–∞ —Å—Ç–∞—Ä–∞—è –ª–æ–≥–∏–∫–∞ ‚Ä¶
}

            const term = filterVal.toLowerCase();
            const okText = !term || decoded.toLowerCase().includes(term) || rawLines[i].toLowerCase().includes(term);
            const okCountry = selectedCountry === 'OFF'
                              || decoded.includes(selectedCountry)
                              || rawLines[i].includes(selectedCountry);
            if (okText && okCountry) {
              results.push(decoded);
            }
            setStatus(`–æ–±—Ä–∞–±–æ—Ç–∫–∞...<br>${Math.round((i + 1) / rawLines.length * 100)}%`, true);
          }
        }

        outEl.value = results.join('\n');
        setStatus('–≥–æ—Ç–æ–≤–æ!', false);
        btnFilter.disabled = false;
      };

      
      
      
      /**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ –≤–ª–æ–∂–µ–Ω–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞ –ø–æ –ø—É—Ç–∏, –∏–ª–∏ undefined.
 */
function getNested(obj, path) {
  return path.reduce((acc, key) =>
    (acc != null ? acc[key] : undefined)
  , obj);
}

/**
 * –°–æ–±–∏—Ä–∞–µ—Ç –≤—Å–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ settings/streamSettings/reality/grpc –∏ —Ç.–ø.
 */
function extractParams(baseObj, params) {
  const mapping = {
    encryption:    ['settings','vnext',0,'users',0,'encryption'],
    flow:          ['settings','vnext',0,'users',0,'flow'],
    security:      ['streamSettings','security'],
    // TLS
    allowInsecure: ['streamSettings','tlsSettings','allowInsecure'],
    alpn:          ['streamSettings','tlsSettings','alpn'],
    fp:            ['streamSettings','tlsSettings','fingerprint'],
    // Reality
    pbk:           ['streamSettings','realitySettings','publicKey'],
    sid:           ['streamSettings','realitySettings','shortId'],
    seed:          ['streamSettings','kcpSettings','seed'],
    // transport
    type:          ['streamSettings','network'],
    host:          ['streamSettings','wsSettings','headers','Host'],
    path:          ['streamSettings','wsSettings','path'],
    // GRPC
    serviceName:   ['streamSettings','grpcSettings','serviceName'],
    // Shadowsocks-only
    ota:           ['settings','servers',0,'ota']
  };

  // –û–±—â–∏–µ —Å–±–æ—Ä—â–∏–∫–∏
  for (const [key, path] of Object.entries(mapping)) {
    let v = getNested(baseObj, path);
    if (v != null && v !== '') {
      if (Array.isArray(v)) v = v.join(',');
      if (typeof v === 'boolean') v = v ? '1' : '0';
      params.set(key, v);
    }
  }

  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π sni: —Å–Ω–∞—á–∞–ª–∞ TLS, –∞ –µ—Å–ª–∏ –Ω–µ—Ç ‚Äî Reality
  const tlsSni = getNested(baseObj, ['streamSettings','tlsSettings','serverName']);
  const relSni = getNested(baseObj, ['streamSettings','realitySettings','serverName']);
  if (tlsSni) params.set('sni', tlsSni);
  else if (relSni) params.set('sni', relSni);
}

/**
 * –û–±—Ä–∞–±–æ—Ç—á–∏–∫ ¬´–º—É—Å–æ—Ä–Ω–æ–≥–æ¬ª VLESS
 */
function handleGarbageVless(obj, urls) {
  if (obj.b !== 'VLESS' || !obj.f || obj.f.protocol !== 'vless') return false;
  const bean = getNested(obj, ['f','settings','vnext',0]);
  const user = bean?.users?.[0];
  if (!bean || !user || !user.id) return false;

  const address = bean.address;
  const port    = bean.port;
  const params  = new URLSearchParams();

  extractParams(obj.f, params);

  const tag = encodeURIComponent(obj.e || obj.tag || '');
  urls.push(`vless://${user.id}@${address}:${port}?${params.toString()}#${tag}`);
  return true;
}

/**
 * –û–±—Ä–∞–±–æ—Ç—á–∏–∫ ¬´–º—É—Å–æ—Ä–Ω–æ–≥–æ¬ª SHADOWSOCKS
 */
function handleGarbageShadowsocks(obj, urls) {
  if (obj.b !== 'SHADOWSOCKS' || !obj.f || !Array.isArray(obj.f.settings?.servers)) return false;
  const server = obj.f.settings.servers[0];
  if (!server.address || !server.method || !server.password || !server.port) return false;

  const params = new URLSearchParams();
  extractParams(obj.f, params);

  const auth = btoa(`${server.method}:${server.password}`).replace(/=+$/, '');
  let url  = `ss://${auth}@${server.address}:${server.port}`;
  const qs = params.toString();
  if (qs) url += `?${qs}`;
  if (obj.e) url += `#${encodeURIComponent(obj.e)}`;

  urls.push(url);
  return true;
}

 function handleSingBoxOutbounds(obj, urls) {
  if (
    typeof obj !== 'object' ||
    !obj.log ||
    !obj.dns ||
    !Array.isArray(obj.inbounds) ||
    !Array.isArray(obj.outbounds) ||
    !obj.route
  ) return false;

  obj.outbounds.forEach(o => {
    let url;

    if (o.type === 'vless' && o.uuid && o.server && o.server_port) {
      const p = new URLSearchParams();
      if (o.flow)                         p.set('flow', o.flow);
      if (o.transport?.type)             p.set('type', o.transport.type);
      if (o.tls?.enabled) {
        p.set('security', o.tls.reality?.enabled ? 'reality' : 'tls');
        if (o.tls.server_name)           p.set('sni', o.tls.server_name);
        if (o.tls.utls?.fingerprint)     p.set('fp', o.tls.utls.fingerprint);
        if (o.tls.reality?.enabled) {
          p.set('pbk', o.tls.reality.public_key);
          p.set('sid', o.tls.reality.short_id);
        }
      }
      if (o.transport?.type === 'grpc' && o.transport.service_name) {
        p.set('serviceName', o.transport.service_name);
      }
      url = `vless://${o.uuid}@${o.server}:${o.server_port}` +
            (p.toString() ? `?${p.toString()}` : '') +
            `#${encodeURIComponent(o.tag||'')}`;
    }
    else if (o.type === 'shadowsocks' && o.server && o.server_port && o.method && o.password) {
      const auth = btoa(`${o.method}:${o.password}`).replace(/=+$/, '');
      const p = new URLSearchParams();
      if (o.ota !== undefined)          p.set('ota', o.ota ? '1' : '0');
      url = `ss://${auth}@${o.server}:${o.server_port}` +
            (p.toString() ? `?${p.toString()}` : '') +
            `#${encodeURIComponent(o.tag||'')}`;
    }
    else if (o.type === 'trojan' && o.password && o.server && o.server_port) {
      const p = new URLSearchParams();
      if (o.tls?.server_name)           p.set('sni', o.tls.server_name);
      url = `trojan://${encodeURIComponent(o.password)}@${o.server}:${o.server_port}` +
            (p.toString() ? `?${p.toString()}` : '') +
            `#${encodeURIComponent(o.tag||'')}`;
    }

    if (url) urls.push(url);
  });

  return true;
}
 
 
document.getElementById('btnConvert').onclick = () => {
  let raw = inEl.value;
  const f = raw.indexOf('{'), l = raw.lastIndexOf('}');
  if (f !== -1 && l > f) raw = raw.slice(f, l + 1);
  if (!raw.trim()) {
    outEl.value = '–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç json';
    return;
  }

  const objs = extractAllJSON(raw), urls = [];
  objs.forEach(obj => {
    if (handleSingBoxOutbounds(obj, urls))      return;
    if (handleGarbageVless(obj, urls))          return;
    if (handleGarbageShadowsocks(obj, urls))    return;
    if (handleSpecialJunkConfig(obj, urls))     return;
    if (handleJunkConfig(obj, urls))            return;
    if (obj.configType === 'VLESS' &&
        obj.customConfig && obj.password && obj.server) {
      buildURLFromLegacy(obj, urls);
      return;
    }
    if (obj.outboundBean) {
      buildURLsFromOutboundBean(obj, urls);
      return;
    }
    if (obj.custom_json &&
        Array.isArray(obj.custom_json.outbounds)) {
      buildURLsFromCustomJSON(obj, urls);
      return;
    }
    if (obj.server && obj.method &&
        obj.password && obj.server_port) {
      const a = btoa(`${obj.method}:${obj.password}`).replace(/=+$/, '');
      let u = `ss://${a}@${obj.server}:${obj.server_port}`;
      if (obj.remarks) u += `#${encodeURIComponent(obj.remarks)}`;
      urls.push(u);
      return;
    }
    if (obj.configType === 'VLESS' &&
        obj.security === 'reality' &&
        obj.server) {
      const p = new URLSearchParams();
      p.set('encryption', obj.method || 'none');
      p.set('security', obj.security);
      if (obj.flow)         p.set('flow', obj.flow);
      if (obj.alpn)         p.set('alpn', Array.isArray(obj.alpn) ? obj.alpn.join(',') : obj.alpn);
      p.set('allowInsecure', obj.insecure ? '1' : '0');
      p.set('type',         obj.network || '');
      if (obj.sni)          p.set('sni', obj.sni);
      if (obj.fingerPrint)  p.set('fp', obj.fingerPrint);
      if (obj.publicKey)    p.set('pbk', obj.publicKey);
      if (obj.shortId)      p.set('sid', obj.shortId);
      if (obj.serviceName)  p.set('serviceName', obj.serviceName);
      const t = obj.remarks ? encodeURIComponent(obj.remarks) : '';
      urls.push(`vless://${obj.password}@${obj.server}:${obj.serverPort}?${p.toString()}#${t}`);
      return;
    }
    (obj.outbounds || obj.fullConfig?.outbounds || []).forEach(o =>
      buildURLFromOutbound(o, obj.remarks, urls)
    );
  });
  outEl.value = urls.join('\n');
};

      document.getElementById('btnConvertBack').onclick = () => {
        const raw = inEl.value.trim();
        if (!raw) { outEl.value = '–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç url'; return; }
        const lines = raw.split(/\r?\n/).filter(Boolean);
        const unified = [];
        lines.forEach(line => {
          (function parseLine(l) {
            if (l.startsWith('ss://')) {
  const [main, hash] = l.slice(5).split('#');
  const tag = hash ? decodeURIComponent(hash) : '';
  const [auth, hp] = main.split('@');
  const [method, password] = atob(auth).split(':');
  // –û–±—Ä–µ–∑–∞–µ–º –≤—Å—ë –ø–æ—Å–ª–µ ? –ø–µ—Ä–µ–¥ —Ä–∞–∑–±–æ—Ä–æ–º –∞–¥—Ä–µ—Å–∞ –∏ –ø–æ—Ä—Ç–∞
  const hostport = hp.split('?')[0];
  const [address, portStr] = hostport.split(':');
  const port = +portStr;
  unified.push({
    protocol: 'shadowsocks',
    tag,
    settings: { servers: [{ address, port, method, password }] },
    streamSettings: { network: 'tcp', security: 'none', tcpSettings: {} }
  });
  return;
}

            if (l.startsWith('wireguard://')) {
              const obj = parseWireguardURL(l);
              if (obj) unified.push(obj);
              return;
            }

            if (l.startsWith('hysteria2://')) {
              try {
                const u = new URL(l);
                const password = decodeURIComponent(u.username);
                const [host,port] = u.host.split(':');
                const p = u.searchParams;
                const insecure = p.get('insecure') === '1';
                const sni = p.get('sni') || '';
                unified.push({
                  protocol:'hysteria2',
                  tag: u.hash ? decodeURIComponent(u.hash.slice(1)) : 'hysteria2',
                  settings:{ servers:[{ address:host, port:parseInt(port,10) }] },
                  streamSettings:{
                    network:'hysteria2', security:'tls',
                    hy2Settings:{ password, use_udp_extension:insecure, congestion:{ down_mbps:0, up_mbps:0 } },
                    tlsSettings:{ allowInsecure:insecure, serverName:sni }
                  },
                  domainStrategy:'AsIs'
                });
              } catch{}
              return;
            }

            try {
              const u = new URL(l);
              const p = u.searchParams;
              const proto = u.protocol.slice(0,-1);
              const tag = decodeURIComponent(u.hash.slice(1)) || proto;
              const typeParam = p.get('type') || 'tcp';
              const headerType = p.get('headerType') || '';
              const h = p.get('host') || '';
              const path = p.get('path') || '';
              const flow = p.get('flow') || '';
              const seed = p.get('seed') || '';
              const serviceName = p.get('serviceName') || '';
              const ssConf = {
                network: typeParam === 'xhttp' ? 'splithttp' : typeParam,
                security: p.get('security') || '',
                packetEncoding: p.get('packetEncoding') || '',
                tlsSettings: {
                  serverName: p.get('sni') || '',
                  allowInsecure: p.get('allowInsecure') === '1',
                  fingerprint: p.get('fp') || '',
                  alpn: p.get('alpn') ? p.get('alpn').split(',') : []
                },
                realitySettings: { publicKey: p.get('pbk') || '', shortId: p.get('sid') || '', serverName: p.get('sni') || '' },
                kcpSettings: { seed: seed },
                grpcSettings: { serviceName: serviceName },
                tcpSettings: headerType==='http'?{ header:{ type:'http', request:{ headers:{ Host:[h] }, path:[path] } } }:undefined,
                httpSettings: typeParam==='http'?{ host:[h], path }:undefined,
                splithttpSettings: typeParam==='xhttp'?{ host:h, path }:undefined,
                httpupgradeSettings: typeParam==='httpupgrade'?{ host:h, path }:undefined,
                wsSettings: typeParam==='ws'&&h?{ headers:{ Host:h }, path }:undefined
              };
         
          if (proto === 'trojan') {
            ssConf.security     = p.get('security') || 'tls';
            ssConf.tlsSettings  = ssConf.tlsSettings || {};
            if (p.get('allowInsecure') === '1') ssConf.tlsSettings.allowInsecure = true;
            const sni = p.get('sni');
            if (sni) ssConf.tlsSettings.serverName = sni;
          }
    
              if (proto==='vless') unified.push({ protocol:'vless', tag, settings:{ vnext:[{ address:u.hostname, port:+u.port, users:[{ id:u.username, encryption:p.get('encryption')||'none', flow, serviceName }] }] }, streamSettings:ssConf });
              if (proto==='vmess') unified.push({ protocol:'vmess', tag, settings:{ vnext:[{ address:u.hostname, port:+u.port, users:[{ id:u.username, security:p.get('encryption')||'auto' }] }] }, streamSettings:ssConf });
              if (proto==='trojan') {
                const pwd = decodeURIComponent(u.username), host2 = u.hostname, port2=+u.port;
                unified.push({ protocol:'trojan', tag, settings:{ servers:[{ address:host2, port:port2, password:pwd }] }, streamSettings:ssConf });
              }
            } catch {}
          })(line);
        });

        const config = {
          dns:{ fallbackStrategy:'disabledIfAnyMatch', servers:[{ address:'8.8.8.8', queryStrategy:'UseIP' }] },
          inbounds:[
            { listen:'0.0.0.0', port:10805, protocol:'socks', settings:{ auth:'noauth', udp:true }, tag:'socks' },
            { listen:'0.0.0.0', port:1080, protocol:'http', settings:{ allowTransparent:true }, tag:'http' },
            { listen:'0.0.0.0', port:10804, protocol:'dokodemo-door', settings:{ address:'0.0.0.0', network:'tcp,udp', port:10804 }, tag:'dns-in' }
          ],
          log:{ loglevel:'warning' },
          outbounds:unified,
          policy:{ levels:{ '1':{ connIdle:30 } }, system:{ statsOutboundDownlink:true, statsOutboundUplink:true } },
          routing:{ domainStrategy:'AsIs', rules:[{ inboundTag:['dns-in'], outboundTag:'dns-out', type:'field' }] },
          stats:{}
        };

        outEl.value = JSON.stringify(config,null,2);
      };

      document.getElementById('btnTextBase64').onclick = () => {
        const t = inEl.value.trim();
        if (!t) { outEl.value = '–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç —Ç–µ–∫—Å—Ç'; return; }
        try { outEl.value = decodeURIComponent(escape(atob(t))); }
        catch { outEl.value = btoa(unescape(encodeURIComponent(t))); }
      };

      document.getElementById('btnCopy').onclick = () => {
        const text = outEl.value;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text).then(() => alert('–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!')).catch(fallback);
        } else fallback();
        function fallback() {
          const ta = document.createElement('textarea');
          ta.value = text; ta.setAttribute('wrap','off');
          ta.style.position = 'absolute'; ta.style.left='-9999px';
          document.body.appendChild(ta);
          ta.select(); ta.setSelectionRange(0,ta.value.length);
          document.execCommand('copy');
          document.body.removeChild(ta);
          alert('–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!');
        }
      };

      document.getElementById('btnDownload').onclick = () => {
        const d = outEl.value.trim();
        if (!d) return alert('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö');
        const link = hiddenDownloadLink;
        link.href = URL.createObjectURL(new Blob([d],{type:'text/plain'}));
        link.download='result.txt'; link.click();
        setTimeout(()=>URL.revokeObjectURL(link.href),1000);
      };

      document.getElementById('btnLoadFile').onclick = () => fileInput.click();
      fileInput.onchange = e => {
        const fr = new FileReader();
        fr.onload = () => inEl.value = fr.result;
        fr.readAsText(e.target.files[0]);
      };

      btnClearInput.addEventListener('click', () => { inEl.value = ''; });
      btnClearOutput.addEventListener('click', () => { outEl.value = ''; });

      btnSettingsLocal.addEventListener('click', () => { settingsModalLocal.style.display='flex'; });
      closeSettingsLocal.addEventListener('click', () => { settingsModalLocal.style.display='none'; });

      function applyReplacement(regex, replacement) {
        const lines = inEl.value.split(/\r?\n/);
        outEl.value = lines.map(l=>l.replace(regex,replacement)).join('\n');
      }

      
  // ‚Ä¶ –≤–∞—à –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ ‚Ä¶

  document.getElementById('btnReplaceWsHost').addEventListener('click', () => {
    const newHost = document.getElementById('replaceWsHostInput').value.trim();
    const lines = inEl.value.trim().split(/\r?\n/);
    const updated = lines.map(l => {
      try {
        const u = new URL(l);
        u.searchParams.set('host', newHost);
        return u.toString();
      } catch {
        return l;
      }
    });
    inEl.value = updated.join('\n');
    settingsModalLocal.style.display = 'none';
    btnFilter.click();
  });

  document.getElementById('btnReplaceSni').addEventListener('click', () => {
    const newSni = document.getElementById('replaceSniInput').value.trim();
    const lines = inEl.value.trim().split(/\r?\n/);
    const updated = lines.map(l => {
      try {
        const u = new URL(l);
        u.searchParams.set('sni', newSni);
        return u.toString();
      } catch {
        return l;
      }
    });
    inEl.value = updated.join('\n');
    settingsModalLocal.style.display = 'none';
    btnFilter.click();
  });

  document.getElementById('btnReplaceName').addEventListener('click', () => {
  const newName = encodeURIComponent(
    document.getElementById('replaceNameInput').value.trim()
  );
  const lines = inEl.value.trim().split(/\r?\n/);
  const updated = lines.map(l => {
    try {
      const u = new URL(l);
      // –í—Å–µ–≥–¥–∞ —Å—Ç–∞–≤–∏–º –Ω–æ–≤—ã–π —Ö—ç—à, –∑–∞–º–µ–Ω—è—è —Å—Ç–∞—Ä—ã–π –∏–ª–∏ –¥–æ–±–∞–≤–ª—è—è –µ–≥–æ, –µ—Å–ª–∏ —Ö—ç—à–∞ –Ω–µ –±—ã–ª–æ
      u.hash = `#${newName}`;
      return u.toString();
    } catch {
      return l;
    }
  });
  inEl.value = updated.join('\n');
  settingsModalLocal.style.display = 'none';
  btnFilter.click();
});

;(function(){
  const btn = document.getElementById('ipWsToggle');
  let toggled = false, orig = '', mod = '';
  btn.addEventListener('click', () => {
    orig = orig || inEl.value.trim();
    try {
      const parsed = JSON.parse(orig);
      parsed.outbounds.forEach(o => {
        const ws = o.streamSettings?.wsSettings?.headers?.Host
                || o.streamSettings?.httpSettings?.host?.[0]
                || o.streamSettings?.splithttpSettings?.host || '';
        if (ws) {
          if (o.settings?.vnext?.[0]) {
            o._orig = o.settings.vnext[0].address;
            o.settings.vnext[0].address = ws;
          } else if (o.settings?.servers?.[0]) {
            o._orig = o.settings.servers[0].address;
            o.settings.servers[0].address = ws;
          }
        }
      });
      mod = JSON.stringify(parsed, null, 2);
    } catch {
      mod = orig.split('\n').map(l => {
        try {
          const u = new URL(l);
          const ws = u.searchParams.get('host');
          if (ws) {
            u.hostname = decodeURIComponent(ws);
            return u.toString();
          }
          return l;
        } catch {
          return l;
        }
      }).join('\n');
    }
    outEl.value = toggled ? orig : mod;
    toggled = !toggled;
    settingsModalLocal.style.display = 'none';
  });
})();

      // –¥–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏—è
      document.getElementById('btnDedup').addEventListener('click', () => {
  const raw = inEl.value.trim();
  let output = '';
  try {
    const cfg = JSON.parse(raw);
    if (Array.isArray(cfg.outbounds)) {
      const seen = new Set();
      const deduped = cfg.outbounds.filter(o => {
        const copy = { ...o };
        delete copy.tag;
        delete copy.remarks;
        const key = JSON.stringify(copy);
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      });
      cfg.outbounds = deduped;
      output = JSON.stringify(cfg, null, 2);
    } else {
      throw '';
    }
  } catch {
    const lines = raw.split(/\r?\n/).filter(Boolean);
    const seen = new Set();
    const deduped = [];
    for (let line of lines) {
      const core = line.split('#')[0];
      if (!seen.has(core)) {
        seen.add(core);
        deduped.push(line);
      }
    }
    output = deduped.join('\n');
  }
  outEl.value = output;
  document.querySelector('#statusContainer #processStatus').innerHTML = '–¥–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∞';
  settingsModalLocal.style.display = 'none';
});

function toSS(o) {
      const b64 = btoa(o.method + ':' + o.password).replace(/=+$/, '');
      return `ss://${b64}@${o.server}:${o.serverPort}#${encodeURIComponent(o.remarks||'')}`;
    }
    
    
(function(){
  const btn = document.getElementById('btnConvert');
  const orig = btn.onclick;          // –±–∞–∑–æ–≤—ã–π JSON‚ÜíURL

  btn.onclick = async function(...args) {
    // 1) –±–∞–∑–æ–≤–∞—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è
    await orig.apply(this, args);

    const raw = inEl.value;

    // 2) NEW JSON BUILDER: \u0002 -> ss://
    const partsSS = raw.split(/\u0002+/);
    const urlsSS = [];
    for (let p of partsSS) {
      const s = p.indexOf('{'), e = p.lastIndexOf('}');
      if (s < 0 || e <= s) continue;
      try {
        const o = JSON.parse(p.slice(s, e + 1));
        if (o.configType === 'SHADOWSOCKS' && o.method && o.password && o.server && o.serverPort) {
          urlsSS.push(toSS(o));
        }
      } catch {}
    }
    if (urlsSS.length) {
      outEl.value += (outEl.value ? '\n' : '') + urlsSS.join('\n');
    }

    // 3) ‚Äú–º—É—Å–æ—Ä–Ω—ã–µ‚Äù VLESS/TROJAN JSON
    const partsJT = raw.split(/\u0002+|\r?\n/);
    const urlsJT = [];
    for (let p of partsJT) {
      const s = p.indexOf('{'), e = p.lastIndexOf('}');
      if (s < 0 || e <= s) continue;
      try {
        const o = JSON.parse(p.slice(s, e + 1));

        if (o.configType === 'TROJAN') {
          const bean = o.outboundBean?.[0];
          const srv  = bean?.settings?.servers?.[0];
          const ss2  = bean?.streamSettings || {};
          if (srv) {
            const qp = new URLSearchParams();
            qp.set('security', ss2.security || 'none');
            qp.set('type', ss2.network || '');
            urlsJT.push(
              `trojan://${encodeURIComponent(srv.password)}@${srv.address}:${srv.port}?${qp.toString()}`
            );
          }
        }

        if (o.configType === 'VLESS') {
          const bean = o.outboundBean?.[0];
          const v    = bean?.settings?.vnext?.[0];
          const u    = v?.users?.[0];
          const ss2  = bean?.streamSettings || {};
          if (v && u) {
            const qp = new URLSearchParams();
            qp.set('encryption', u.encryption || 'none');
            qp.set('security', ss2.security || 'none');
            qp.set('type', ss2.network || '');
            urlsJT.push(
              `vless://${u.id}@${v.address}:${v.port}?${qp.toString()}`
            );
          }
        }
      } catch {}
    }
    if (urlsJT.length) {
      outEl.value += (outEl.value ? '\n' : '') + urlsJT.join('\n');
    }
  };
})();


(function(){
  const btn = document.getElementById('btnConvert');
  const orig2 = btn.onclick;
  btn.onclick = async function(...args) {
    await orig2.apply(this, args);

    const lines = inEl.value.trim().split(/\r?\n/).filter(Boolean);
    const wgLines = lines.filter(l => l.startsWith('wireguard://'));
    if (wgLines.length) {
      const iniBlocks = wgLines.map(parseWireguardToIni).filter(Boolean);
      outEl.value += (outEl.value ? '\n\n' : '') + iniBlocks.join('\n\n');
    }

    const iniText = inEl.value.trim();
    if (iniText.startsWith('[Interface]')) {
      const url = parseIniToWireguard(iniText);
      outEl.value += (outEl.value ? '\n' : '') + url;
    }
  };
})();
    });
    

   
  </script>
</body>
</html>