<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>V2RAY Converter (Vmess Vless Trojan Shadowsocks) Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * { font-weight: bold !important; }
    body { background: #121212; color: #eee; font-family: monospace; margin: 0; padding: 10px; display: flex; flex-direction: column; height: 100vh; box-sizing: border-box; }
    h2 { text-align: center; margin: 10px 0 20px; font-size: 1.2em; }
    .container { flex: 1; display: flex; flex-direction: column; gap: 10px; overflow: hidden; }
    .label { color: #bbb; font-size: 0.9em; margin-bottom: 4px; user-select: none; }
    textarea { width: 100%; height: 150px; background: #1e1e1e; color: #eee; padding: 10px; border-radius: 5px; resize: vertical; box-sizing: border-box; font-size: 14px; line-height: 1.3em; border: 3px solid; font-family: monospace; }
    #inputConfig { border-color: #28a745; }
    #outputResult { border-color: #dc3545; }
    .buttons-row { display: flex; width: 100%; gap: 10px; margin-top: 5px; }
    .buttons-left, .buttons-right { display: flex; flex-direction: column; gap: 10px; width: 50%; }
    .clear-row { margin-top: 10px; width: 100%; }
    .clear-row button { width: 100%; }
    button { color: #fff; padding: 10px 15px; border: none; cursor: pointer; border-radius: 5px; font-size: 14px; user-select: none; white-space: nowrap; transition: filter .2s ease; text-align: center; }
    #btnConvert { background: #28a745; }
    #btnConvertBack { background: #007bff; }
    #btnTextBase64 { background: #ff9800; }
    #btnClear { background: #dc3545; }
    #btnCopy, #btnDownload { background: #000; border: 2px solid #999; }
    #btnLoadFile { background: #6c757d; }
    button:hover { filter: brightness(1.2); }
    #fileInput { display: none; }

    /* GeoIP Ğ¸ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€ */
    #filterRow { display: flex; flex-direction: column; gap: 5px; margin-bottom: 2px; position: relative; }
    #geoRow { display: flex; align-items: center; gap: 8px; }
    #ipGeoToggle { width: 20px; height: 20px; cursor: pointer; }
    #ipGeoLabel { font-size: 0.9em; margin-left: -7px; color: #bbb; user-select: none; }
    #geoServiceInput { flex: 1; height: 36px; max-width: 190px; padding: 0 10px; font-size: 14px; border: 3px solid #007bff; border-radius: 5px; background: #1e1e1e; color: #eee; box-sizing: border-box; }
    #statusContainer { display: flex; flex-direction: column; align-items: flex-start; color: #00ffee; font-size: 0.9em; }
    .spinner { width: 16px; height: 16px; margin-bottom: 2px; border: 2px solid #0af33; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; display: none; }
    @keyframes spin { to { transform: rotate(360deg); } }

    #controlsRow { display: flex; gap: 7px; align-items: center; }
    #btnCountry { width: 36px; height: 36px; background: #007bff; border-radius: 5px; display: flex; align-items: center; justify-content: center; font-size: 18px; }
    #btnPing { width: 36px; height: 36px; background: #474747; border-radius: 5px; display: flex; align-items: center; justify-content: center; font-size: 14px; line-height: 1em; padding:0; }
    #btnPing span { line-height: 1em; }
    #filterInput { flex: 1; height: 36px; padding: 0 10px; font-size: 14px; border: 3px solid #007bff; border-radius: 5px; background: #1e1e1e; color: #eee; box-sizing: border-box; }
    #btnFilter { background: #007bff; color: #fff; border: none; border-radius: 5px; padding: 0 15px; font-size: 14px; cursor: pointer; height: 36px; }

    #countryPopup { position: absolute; top: 96px; left: 10; width: 59vw; max-width: calc(100% - 20px); height: calc(100vh - 210px); background: #1e1e1e; border: 3px solid #007bff; border-radius: 5px; overflow: hidden; display: none; box-sizing: border-box; z-index:100; }
    #countryPopup .search-container { position: sticky; top: 0; background: #1e1e1e; padding: 10px; z-index: 1; box-shadow: 0 2px 4px rgba(0,0,0,0.5); }
    #countryPopup .search-container input { width: calc(100% - 20px); padding: 6px 10px; font-size: 14px; border: 2px solid #007bff; border-radius: 4px; background: #2a2a2a; color: #eee; box-sizing: border-box; }
    #countryPopup .country-list { height: calc(100% - 56px); overflow-y: auto; }
    #countryPopup .country-item { display: flex; align-items: center; padding: 6px 10px; cursor: pointer; }
    #countryPopup .country-item:hover { background: #007bff22; }
    #countryPopup .country-item span { margin-left: 5px; }
    #countryPopup .country-item span:first-child { font-family: "Noto Color Emoji","Apple Color Emoji","Segoe UI Emoji",sans-serif; }

    @media (max-width:480px) {
      textarea { height: 130px; font-size:13px; }
      .buttons-left button, .buttons-right button, #btnFilter, #btnCountry, #btnPing { font-size:13px; padding:8px 12px; }
      #filterInput, #geoServiceInput { font-size:13px; height:32px; }
      #btnCountry, #btnPing { width:32px; height:32px; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4/dist/js-yaml.min.js"></script>
</head>
<body>
  <h2>V2RAY Converter (Vmess Vless Trojan Shadowsocks) test</h2>

  <div id="filterRow">
    <div id="geoRow">
      <input type="checkbox" id="ipGeoToggle">
      <label for="ipGeoToggle" id="ipGeoLabel">GeoIP</label>
      <input id="geoServiceInput" type="text" placeholder="https://ipwhois.app/json/{ip}" value="https://ipwhois.app/json/{ip}">
      <div id="statusContainer">
        <div class="spinner" id="spinner"></div>
        <span id="processStatus"></span>
      </div>
    </div>
    <div class="label">
      <span>Ğ¡Ñ‚Ñ€Ğ°Ğ½Ñ‹</span><span style="margin-left:60px;">Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ Ğ¿Ğ¾Ğ¸ÑĞºĞ°/ URL-Sub</span>
      <div id="controlsRow">
        <button id="btnCountry">ğŸŒ</button>
        <button id="btnPing"><span>pi<br>ng</span></button>
        <input id="filterInput" placeholder="ĞºĞ»ÑÑ‡ĞµĞ²Ğ¾Ğ¹ Ñ‚ĞµĞºÑÑ‚/Ñ„Ğ»Ğ°Ğ³/URL" />
        <button id="btnFilter">Ğ¾Ğº</button>
      </div>
      <div id="countryPopup"></div>
    </div>
  </div>

  <div class="container">
    <div><div class="label">Ğ˜ÑÑ…Ğ¾Ğ´Ğ½Ñ‹Ğ¹ JSON, URL, Ñ‚ĞµĞºÑÑ‚</div><textarea id="inputConfig" placeholder="Ğ’ÑÑ‚Ğ°Ğ²ÑŒ json, url, Ñ‚ĞµĞºÑÑ‚..."></textarea></div>
    <div><div class="label">Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚</div><textarea id="outputResult" placeholder="Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚..."></textarea></div>
    <div class="buttons-row">
      <div class="buttons-left">
        <button id="btnConvert">json â†’ url</button>
        <button id="btnConvertBack">url â†’ json</button>
        <button id="btnTextBase64">Ñ‚ĞµĞºÑÑ‚ â†” base64</button>
      </div>
      <div class="buttons-right">
        <button id="btnCopy">ÑĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ</button>
        <button id="btnDownload">ÑĞºĞ°Ñ‡Ğ°Ñ‚ÑŒ</button>
        <button id="btnLoadFile">Ğ·Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»</button>
      </div>
    </div>
    <div class="clear-row"><button id="btnClear">Ğ¾Ñ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ</button></div>
  </div>

  <input type="file" id="fileInput" accept=".txt,.json,.yaml,.yml">
  <a id="hiddenDownloadLink" style="display:none;"></a>

  <script>
    
const countries = [
  { flag: 'ğŸŒ', name: 'OFF' },
  { flag: 'ğŸ‡¦ğŸ‡«', name: 'AFGHANISTAN' },
  { flag: 'ğŸ‡¦ğŸ‡½', name: 'ALAND ISLAND' },
  { flag: 'ğŸ‡¦ğŸ‡±', name: 'ALBANIA' },
  { flag: 'ğŸ‡©ğŸ‡¿', name: 'ALGERIA' },
  { flag: 'ğŸ‡¦ğŸ‡¸', name: 'AMERICAN SAMOA' },
  { flag: 'ğŸ‡¦ğŸ‡©', name: 'ANDORRA' },
  { flag: 'ğŸ‡¦ğŸ‡´', name: 'ANGOLA' },
  { flag: 'ğŸ‡¦ğŸ‡®', name: 'ANGUILLA' },
  { flag: 'ğŸ‡¦ğŸ‡¬', name: 'ANTIGUA AND BARBUDA' },
  { flag: 'ğŸ‡¦ğŸ‡¶', name: 'ANTARCTICA' },
  { flag: 'ğŸ‡¦ğŸ‡·', name: 'ARGENTINA' },
  { flag: 'ğŸ‡¦ğŸ‡²', name: 'ARMENIA' },
  { flag: 'ğŸ‡¦ğŸ‡¼', name: 'ARUBA' },
  { flag: 'ğŸ‡¦ğŸ‡¨', name: 'ASCENSION ISLAND' },
  { flag: 'ğŸ‡¦ğŸ‡º', name: 'AUSTRALIA' },
  { flag: 'ğŸ‡¦ğŸ‡¹', name: 'AUSTRIA' },
  { flag: 'ğŸ‡¦ğŸ‡¿', name: 'AZERBAIJAN' },
  { flag: 'ğŸ‡§ğŸ‡¸', name: 'BAHAMAS' },
  { flag: 'ğŸ‡§ğŸ‡­', name: 'BAHRAIN' },
  { flag: 'ğŸ‡§ğŸ‡©', name: 'BANGLADESH' },
  { flag: 'ğŸ‡§ğŸ‡§', name: 'BARBADOS' },
  { flag: 'ğŸ‡§ğŸ‡¾', name: 'BELARUS' },
  { flag: 'ğŸ‡§ğŸ‡ª', name: 'BELGIUM' },
  { flag: 'ğŸ‡§ğŸ‡¿', name: 'BELIZE' },
  { flag: 'ğŸ‡§ğŸ‡¯', name: 'BENIN' },
  { flag: 'ğŸ‡§ğŸ‡´', name: 'BOLIVIA (PLURINATIONAL STATE OF)' },
  { flag: 'ğŸ‡§ğŸ‡¦', name: 'BOSNIA AND HERZEGOVINA' },
  { flag: 'ğŸ‡§ğŸ‡»', name: 'BOUVET ISLAND' },
  { flag: 'ğŸ‡§ğŸ‡¼', name: 'BOTSWANA' },
  { flag: 'ğŸ‡§ğŸ‡·', name: 'BRAZIL' },
 { flag: 'ğŸ‡®ğŸ‡´', name: 'BRITISH INDIAN OCEAN TERRITORY' },
  { flag: 'ğŸ‡§ğŸ‡³', name: 'BRUNEI DARUSSALAM' },
  { flag: 'ğŸ‡§ğŸ‡¬', name: 'BULGARIA' },
  { flag: 'ğŸ‡§ğŸ‡«', name: 'BURKINA FASO' },
  { flag: 'ğŸ‡§ğŸ‡®', name: 'BURUNDI' },
{ flag: 'ğŸ‡³ğŸ‡¨', name: 'CALEDONIA NEW' },
  { flag: 'ğŸ‡°ğŸ‡­', name: 'CAMBODIA' },
  { flag: 'ğŸ‡¨ğŸ‡²', name: 'CAMEROON' },
  { flag: 'ğŸ‡¨ğŸ‡¦', name: 'CANADA' },
  { flag: 'ğŸ‡®ğŸ‡¨', name: 'CANARY ISLANDS' },
  { flag: 'ğŸ‡¨ğŸ‡»', name: 'CAPE VERDE' },
 { flag: 'ğŸ‡§ğŸ‡¶', name: 'CARRIBBEAN NETHERLANDS' },
  { flag: 'ğŸ‡¨ğŸ‡«', name: 'CENTRAL AFRICAN REPUBLIC' },
  { flag: 'ğŸ‡¹ğŸ‡©', name: 'CHAD' },
  { flag: 'ğŸ‡¨ğŸ‡±', name: 'CHILE' },
  { flag: 'ğŸ‡¨ğŸ‡³', name: 'CHINA' },
  { flag: 'ğŸ‡¨ğŸ‡½', name: 'CHRISTMAS ISLAND' },
 { flag: 'ğŸ‡¨ğŸ‡µ', name: 'CLIPPERTON ISLAND' },
  { flag: 'ğŸ‡¨ğŸ‡¨', name: 'COCOS (KEELING) ISLANDS' },
  { flag: 'ğŸ‡¨ğŸ‡´', name: 'COLOMBIA' },
  { flag: 'ğŸ‡°ğŸ‡²', name: 'COMOROS' },
  { flag: 'ğŸ‡¨ğŸ‡¬', name: 'CONGO' },
  { flag: 'ğŸ‡¨ğŸ‡©', name: 'CONGO, THE DEMOCRATIC REPUBLIC OF THE' },
  { flag: 'ğŸ‡¨ğŸ‡°', name: 'COOK ISLANDS' },
  { flag: 'ğŸ‡¨ğŸ‡·', name: 'COSTA RICA' },
 { flag: 'ğŸ‡¨ğŸ‡®', name: 'COTE D`IVOIRE' },
  { flag: 'ğŸ‡­ğŸ‡·', name: 'CROATIA' },
  { flag: 'ğŸ‡¨ğŸ‡º', name: 'CUBA' },
  { flag: 'ğŸ‡¨ğŸ‡¼', name: 'CURAÃ‡AO' },
  { flag: 'ğŸ‡¨ğŸ‡¾', name: 'CYPRUS' },
  { flag: 'ğŸ‡¨ğŸ‡¿', name: 'CZECHIA' },
  { flag: 'ğŸ‡©ğŸ‡°', name: 'DENMARK' },
 { flag: 'ğŸ‡©ğŸ‡¬', name: 'DIEGO GARCIA' },
  { flag: 'ğŸ‡©ğŸ‡¯', name: 'DJIBOUTI' },
  { flag: 'ğŸ‡©ğŸ‡²', name: 'DOMINICA' },
  { flag: 'ğŸ‡©ğŸ‡´', name: 'DOMINICAN REPUBLIC' },
  { flag: 'ğŸ‡ªğŸ‡¨', name: 'ECUADOR' },
  { flag: 'ğŸ‡ªğŸ‡¬', name: 'EGYPT' },
  { flag: 'ğŸ‡¸ğŸ‡»', name: 'EL SALVADOR' },
  { flag: 'ğŸ‡¬ğŸ‡¶', name: 'EQUATORIAL GUINEA' },
  { flag: 'ğŸ‡ªğŸ‡·', name: 'ERITREA' },
  { flag: 'ğŸ‡ªğŸ‡ª', name: 'ESTONIA' },
  { flag: 'ğŸ‡¸ğŸ‡¿', name: 'ESWATINI' },
  { flag: 'ğŸ‡ªğŸ‡¹', name: 'ETHIOPIA' },
  { flag: 'ğŸ‡ªğŸ‡º', name: 'EUROPEAN UNION' },
  { flag: 'ğŸ‡«ğŸ‡°', name: 'FALKLAND ISLANDS (MALVINAS)' },
  { flag: 'ğŸ‡«ğŸ‡´', name: 'FAROE ISLANDS' },
  { flag: 'ğŸ‡«ğŸ‡¯', name: 'FIJI' },
  { flag: 'ğŸ‡«ğŸ‡®', name: 'FINLAND' },
  { flag: 'ğŸ‡«ğŸ‡·', name: 'FRANCE' },
  { flag: 'ğŸ‡¹ğŸ‡«', name: 'FRENCH SOUTHERN TERRITORIES' },
  { flag: 'ğŸ‡¬ğŸ‡¦', name: 'GABON' },
  { flag: 'ğŸ‡¬ğŸ‡²', name: 'GAMBIA' },
  { flag: 'ğŸ‡©ğŸ‡ª', name: 'GERMANY' },
  { flag: 'ğŸ‡¬ğŸ‡­', name: 'GHANA' },
  { flag: 'ğŸ‡¬ğŸ‡®', name: 'GIBRALTAR' },
  { flag: 'ğŸ‡¬ğŸ‡·', name: 'GREECE' },
  { flag: 'ğŸ‡¬ğŸ‡±', name: 'GREENLAND' },
  { flag: 'ğŸ‡¬ğŸ‡©', name: 'GRENADA' },
  { flag: 'ğŸ‡¬ğŸ‡ª', name: 'GEORGIA' },
  { flag: 'ğŸ‡¬ğŸ‡¬', name: 'GUERNSEY' },
  { flag: 'ğŸ‡¬ğŸ‡º', name: 'GUAM' },
{ flag: 'ğŸ‡¬ğŸ‡«', name: 'GUIANA FRENCH' },
  { flag: 'ğŸ‡µğŸ‡¬', name: 'GUINEA NEW(PAPUA)' },
  { flag: 'ğŸ‡¬ğŸ‡³', name: 'GUINEA' },
  { flag: 'ğŸ‡¬ğŸ‡¼', name: 'GUINEA-BISSAU' },
  { flag: 'ğŸ‡¬ğŸ‡¾', name: 'GUYANA' },
  { flag: 'ğŸ‡­ğŸ‡¹', name: 'HAITI' },
  { flag: 'ğŸ‡­ğŸ‡²', name: 'HEARD ISLAND AND MCDONALD ISLANDS' },
  { flag: 'ğŸ‡­ğŸ‡³', name: 'HONDURAS' },
  { flag: 'ğŸ‡­ğŸ‡°', name: 'HONG KONG' },
  { flag: 'ğŸ‡­ğŸ‡º', name: 'HUNGARY' },
  { flag: 'ğŸ‡®ğŸ‡³', name: 'INDIA' },
  { flag: 'ğŸ‡®ğŸ‡©', name: 'INDONESIA' },
  { flag: 'ğŸ‡®ğŸ‡·', name: 'IRAN (ISLAMIC REPUBLIC OF)' },
  { flag: 'ğŸ‡®ğŸ‡¶', name: 'IRAQ' },
  { flag: 'ğŸ‡®ğŸ‡ª', name: 'IRELAND' },
  { flag: 'ğŸ‡®ğŸ‡±', name: 'ISRAEL' },
  { flag: 'ğŸ‡®ğŸ‡²', name: 'ISLE OF MAN' },
  { flag: 'ğŸ‡®ğŸ‡¹', name: 'ITALY' },
  { flag: 'ğŸ‡¯ğŸ‡²', name: 'JAMAICA' },
  { flag: 'ğŸ‡¯ğŸ‡µ', name: 'JAPAN' },
  { flag: 'ğŸ‡¯ğŸ‡ª', name: 'JERSEY' },
  { flag: 'ğŸ‡¯ğŸ‡´', name: 'JORDAN' },
  { flag: 'ğŸ‡°ğŸ‡¿', name: 'KAZAKHSTAN' },
  { flag: 'ğŸ‡°ğŸ‡ª', name: 'KENYA' },
  { flag: 'ğŸ‡°ğŸ‡®', name: 'KIRIBATI' },
  { flag: 'ğŸ‡½ğŸ‡°', name: 'KOSOVO' },
  { flag: 'ğŸ‡°ğŸ‡¼', name: 'KUWAIT' },
  { flag: 'ğŸ‡°ğŸ‡¬', name: 'KYRGYZSTAN' },
  { flag: 'ğŸ‡±ğŸ‡¦', name: "LAO PEOPLE'S DEMOCRATIC REPUBLIC" },
  { flag: 'ğŸ‡±ğŸ‡»', name: 'LATVIA' },
  { flag: 'ğŸ‡±ğŸ‡§', name: 'LEBANON' },
  { flag: 'ğŸ‡±ğŸ‡¸', name: 'LESOTHO' },
  { flag: 'ğŸ‡±ğŸ‡·', name: 'LIBERIA' },
  { flag: 'ğŸ‡±ğŸ‡¾', name: 'LIBYA' },
  { flag: 'ğŸ‡±ğŸ‡®', name: 'LIECHTENSTEIN' },
  { flag: 'ğŸ‡±ğŸ‡¹', name: 'LITHUANIA' },
  { flag: 'ğŸ‡±ğŸ‡º', name: 'LUXEMBOURG' },
  { flag: 'ğŸ‡²ğŸ‡´', name: 'MACAO, SPECIAL ADMINISTRATIVE REGION OF CHINA' },
  { flag: 'ğŸ‡²ğŸ‡°', name: 'MACEDONIA NORTH' },
  { flag: 'ğŸ‡²ğŸ‡¬', name: 'MADAGASCAR' },
  { flag: 'ğŸ‡²ğŸ‡¼', name: 'MALAWI' },
  { flag: 'ğŸ‡²ğŸ‡¾', name: 'MALAYSIA' },
  { flag: 'ğŸ‡²ğŸ‡»', name: 'MALDIVES' },
  { flag: 'ğŸ‡²ğŸ‡±', name: 'MALI' },
  { flag: 'ğŸ‡²ğŸ‡¹', name: 'MALTA' },
  { flag: 'ğŸ‡²ğŸ‡­', name: 'MARSHALL ISLANDS' },
  { flag: 'ğŸ‡²ğŸ‡¶', name: 'MARTINIQUE' },
  { flag: 'ğŸ‡²ğŸ‡·', name: 'MAURITANIA' },
  { flag: 'ğŸ‡²ğŸ‡º', name: 'MAURITIUS' },
  { flag: 'ğŸ‡¾ğŸ‡¹', name: 'MAYOTTE' },
  { flag: 'ğŸ‡²ğŸ‡µ', name: 'MARIANA NORTHERN ISLANDS' },
  { flag: 'ğŸ‡²ğŸ‡½', name: 'MEXICO' },
  { flag: 'ğŸ‡«ğŸ‡²', name: 'MICRONESIA (FEDERATED STATES OF)' },
  { flag: 'ğŸ‡²ğŸ‡©', name: 'MOLDOVA, REPUBLIC OF' },
  { flag: 'ğŸ‡²ğŸ‡¨', name: 'MONACO' },
  { flag: 'ğŸ‡²ğŸ‡³', name: 'MONGOLIA' },
  { flag: 'ğŸ‡²ğŸ‡ª', name: 'MONTENEGRO' },
  { flag: 'ğŸ‡²ğŸ‡¸', name: 'MONTSERRAT' },
  { flag: 'ğŸ‡²ğŸ‡¦', name: 'MOROCCO' },
  { flag: 'ğŸ‡²ğŸ‡¿', name: 'MOZAMBIQUE' },
  { flag: 'ğŸ‡²ğŸ‡²', name: 'MYANMAR' },
  { flag: 'ğŸ‡³ğŸ‡¦', name: 'NAMIBIA' },
  { flag: 'ğŸ‡³ğŸ‡·', name: 'NAURU' },
  { flag: 'ğŸ‡³ğŸ‡µ', name: 'NEPAL' },
  { flag: 'ğŸ‡³ğŸ‡±', name: 'NETHERLANDS' },
  { flag: 'ğŸ‡³ğŸ‡®', name: 'NICARAGUA' },
  { flag: 'ğŸ‡³ğŸ‡ª', name: 'NIGER' },
  { flag: 'ğŸ‡³ğŸ‡¬', name: 'NIGERIA' },
  { flag: 'ğŸ‡³ğŸ‡º', name: 'NIUE' },
  { flag: 'ğŸ‡³ğŸ‡«', name: 'NORFOLK ISLAND' },
  { flag: 'ğŸ‡³ğŸ‡´', name: 'NORWAY' },
  { flag: 'ğŸ‡´ğŸ‡²', name: 'OMAN' },
  { flag: 'ğŸ‡µğŸ‡°', name: 'PAKISTAN' },
  { flag: 'ğŸ‡µğŸ‡¼', name: 'PALAU' },
  { flag: 'ğŸ‡µğŸ‡¸', name: 'PALESTINE, STATE OF' },
  { flag: 'ğŸ‡µğŸ‡¦', name: 'PANAMA' },
  { flag: 'ğŸ‡µğŸ‡¾', name: 'PARAGUAY' },
  { flag: 'ğŸ‡µğŸ‡ª', name: 'PERU' },
  { flag: 'ğŸ‡µğŸ‡­', name: 'PHILIPPINES' },
  { flag: 'ğŸ‡µğŸ‡³', name: 'PITCAIRN' },
  { flag: 'ğŸ‡µğŸ‡±', name: 'POLAND' },
 { flag: 'ğŸ‡µğŸ‡«', name: 'POLYNESIA FRENCH' },
  { flag: 'ğŸ‡µğŸ‡¹', name: 'PORTUGAL' },
 { flag: 'ğŸ‡µğŸ‡·', name: 'PUERTO RICO' },
 { flag: 'ğŸ‡¶ğŸ‡¦', name: 'QATAR' },
  { flag: 'ğŸ‡·ğŸ‡ª', name: 'RÃ‰UNION' },
  { flag: 'ğŸ‡·ğŸ‡´', name: 'ROMANIA' },
  { flag: 'ğŸ‡·ğŸ‡¸', name: 'SERBIA' },
  { flag: 'ğŸ‡·ğŸ‡º', name: 'RUSSIAN FEDERATION' },
  { flag: 'ğŸ‡·ğŸ‡¼', name: 'RWANDA' },
  { flag: 'ğŸ‡§ğŸ‡±', name: 'SAINT BARTHÃ‰LEMY' },
  { flag: 'ğŸ‡¸ğŸ‡­', name: 'SAINT HELENA, ASCENSION AND TRISTAN DA CUNHA' },
  { flag: 'ğŸ‡°ğŸ‡³', name: 'SAINT KITTS AND NEVIS' },
  { flag: 'ğŸ‡±ğŸ‡¨', name: 'SAINT LUCIA' },
  { flag: 'ğŸ‡µğŸ‡²', name: 'SAINT PIERRE AND MIQUELON' },
  { flag: 'ğŸ‡²ğŸ‡«', name: 'SAINT MARTIN (FRENCH PART)' },
  { flag: 'ğŸ‡»ğŸ‡¨', name: 'SAINT VINCENT AND THE GRENADINES' },
  { flag: 'ğŸ‡¸ğŸ‡²', name: 'SAN MARINO' },
  { flag: 'ğŸ‡¸ğŸ‡¹', name: 'SAO TOME AND PRINCIPE' },
 { flag: 'ğŸ‡¸ğŸ‡¦', name: 'SAUDI ARABIA' },
  { flag: 'ğŸ‡¸ğŸ‡³', name: 'SENEGAL' },
  { flag: 'ğŸ‡¸ğŸ‡¨', name: 'SEYCHELLES' },
 { flag: 'ğŸ‡±ğŸ‡°', name: 'SHRI LANKA' },
  { flag: 'ğŸ‡¸ğŸ‡±', name: 'SIERRA LEONE' },
  { flag: 'ğŸ‡¸ğŸ‡¬', name: 'SINGAPORE' },
  { flag: 'ğŸ‡¸ğŸ‡½', name: 'SINT MAARTEN (DUTCH PART)' },
  { flag: 'ğŸ‡¸ğŸ‡°', name: 'SLOVAKIA' },
  { flag: 'ğŸ‡¸ğŸ‡®', name: 'SLOVENIA' },
  { flag: 'ğŸ‡¸ğŸ‡§', name: 'SOLOMON ISLANDS' },
  { flag: 'ğŸ‡¸ğŸ‡´', name: 'SOMALIA' },
  { flag: 'ğŸ‡¸ğŸ‡¸', name: 'SOUTH SUDAN' },
  { flag: 'ğŸ‡¿ğŸ‡¦', name: 'SOUTH AFRICA' },
  { flag: 'ğŸ‡¬ğŸ‡¸', name: 'SOUTH GEORGIA AND THE SOUTH SANDWICH ISLANDS' }, 
 { flag: 'ğŸ‡ªğŸ‡¦', name: 'SPAIN' },
  { flag: 'ğŸ‡ªğŸ‡¸', name: 'SPAIN CEUTA AND MELILLA' },
  { flag: 'ğŸ‡¸ğŸ‡·', name: 'SURINAME' },
  { flag: 'ğŸ‡¸ğŸ‡©', name: 'SUDAN' },
 { flag: 'ğŸ‡¨ğŸ‡­', name: 'SWITZERLAND' },
  { flag: 'ğŸ‡¸ğŸ‡¾', name: 'SYRIA' },
  { flag: 'ğŸ‡¹ğŸ‡¯', name: 'TAJIKISTAN' },
  { flag: 'ğŸ‡¹ğŸ‡¿', name: 'TANZANIA, UNITED REPUBLIC OF' },
  { flag: 'ğŸ‡¹ğŸ‡­', name: 'THAILAND' },
  { flag: 'ğŸ‡¹ğŸ‡±', name: 'TIMOR-LESTE' },
  { flag: 'ğŸ‡¹ğŸ‡¬', name: 'TOGO' },
  { flag: 'ğŸ‡¹ğŸ‡°', name: 'TOKELAU' },
  { flag: 'ğŸ‡¹ğŸ‡´', name: 'TONGA' },
  { flag: 'ğŸ‡¹ğŸ‡·', name: 'TURKEY' },
  { flag: 'ğŸ‡¹ğŸ‡²', name: 'TURKMENISTAN' },
  { flag: 'ğŸ‡¹ğŸ‡¨', name: 'TURKS AND CAICOS ISLANDS' },
  { flag: 'ğŸ‡¹ğŸ‡»', name: 'TUVALU' },
  { flag: 'ğŸ‡ºğŸ‡¬', name: 'UGANDA' },
  { flag: 'ğŸ‡ºğŸ‡¦', name: 'UKRAINE' },
  { flag: 'ğŸ‡¦ğŸ‡ª', name: 'UNITED ARAB EMIRATES' },
  { flag: 'ğŸ‡¬ğŸ‡§', name: 'UNITED KINGDOM' },
  { flag: 'ğŸ‡ºğŸ‡³', name: 'UNITED NATIONS' },
  { flag: 'ğŸ‡ºğŸ‡¸', name: 'UNITED STATES OF AMERICA' },
  { flag: 'ğŸ‡ºğŸ‡¾', name: 'URUGUAY' },
  { flag: 'ğŸ‡ºğŸ‡¿', name: 'UZBEKISTAN' },
  { flag: 'ğŸ‡»ğŸ‡¦', name: 'VATICAN CITY' },
  { flag: 'ğŸ‡»ğŸ‡º', name: 'VANUATU' },
  { flag: 'ğŸ‡»ğŸ‡ª', name: 'VENEZUELA (BOLIVARIAN REPUBLIC OF)' },
  { flag: 'ğŸ‡»ğŸ‡³', name: 'VIETNAM' },
  { flag: 'ğŸ‡»ğŸ‡¬', name: 'VIRGIN ISLANDS (BRITISH)' },
  { flag: 'ğŸ‡»ğŸ‡®', name: 'VIRGIN ISLANDS (U.S.)' },
 { flag: 'ğŸ´ó §ó ¢ó ·ó ¬ó ³ó ¿', name: 'WALES' },
  { flag: 'ğŸ‡¼ğŸ‡«', name: 'WALLIS AND FUTUNA' },
  { flag: 'ğŸ‡ªğŸ‡­', name: 'WESTERN SAHARA' },
  { flag: 'ğŸ‡¾ğŸ‡ª', name: 'YEMEN' },
  { flag: 'ğŸ‡¿ğŸ‡²', name: 'ZAMBIA' },
   { flag: 'ğŸ‡³ğŸ‡¿', name: 'ZEALAND NEW' },
  { flag: 'ğŸ‡¿ğŸ‡¼', name: 'ZIMBABWE' },
];

    function extractAllJSON(text) {
      const res = [], stack = [], starts = [];
      for (let i = 0; i < text.length; i++) {
        if (text[i] === '{') {
          if (!stack.length) starts.push(i);
          stack.push('{');
        } else if (text[i] === '}') {
          stack.pop();
          if (!stack.length && starts.length) {
            const s = starts.pop();
            try { res.push(JSON.parse(text.slice(s, i + 1))); } catch{}
          }
        }
      }
      return res;
    }

    function countryCodeToFlag(cc) {
      return cc.toUpperCase().replace(/./g, c => String.fromCodePoint(0x1F1E6 + c.charCodeAt(0) - 65));
    }

    function buildGeoUrl(host) {
      const tpl = document.getElementById('geoServiceInput').value.trim().replace(/\/+$/, '');
      if (tpl.includes('{ip}')) return tpl.replace(/{ip}/g, host);
      if (tpl.includes('?')) return `${tpl}&ip=${host}`;
      return `${tpl}/${host}`;
    }

    // ĞĞ¾Ğ²Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´ĞµĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ vmess://<Base64>
    function decodeVmessBase64(line) {
      try {
        const b64 = line.replace(/^vmess:\/\//, '').trim();
        const json = JSON.parse(atob(b64));
        const ps = encodeURIComponent(json.ps || '');
        const add = json.add;
        const port = json.port;
        const id  = json.id;
        const params = new URLSearchParams();
        if (json.security)      params.set('security', json.security);
        if (json.encryption)    params.set('encryption', json.encryption);
        if (json.net)           params.set('type', json.net);
        if (json.type)          params.set('headerType', json.type);
        if (json.host)          params.set('host', json.host);
        if (json.path)          params.set('path', json.path);
        if (json.sni)           params.set('sni', json.sni);
        if (json.fingerprint)   params.set('fp', json.fingerprint);
        if (json.alpn)          params.set('alpn', Array.isArray(json.alpn) ? json.alpn.join(',') : json.alpn);
        if (json.flow)          params.set('flow', json.flow);
        if (json.pbk)           params.set('pbk', json.pbk);
        if (json.sid)           params.set('sid', json.sid);
        if (json.seed)          params.set('seed', json.seed);
        if (json.serviceName)   params.set('serviceName', json.serviceName);
        if (json.allowInsecure) params.set('allowInsecure', json.allowInsecure ? '1' : '0');
        const query = params.toString();
        return `vmess://${id}@${add}:${port}${query ? '?' + query : ''}#${ps}`;
      } catch {
        return line;
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      const inEl = document.getElementById('inputConfig'),
            outEl = document.getElementById('outputResult'),
            filterInput = document.getElementById('filterInput'),
            btnFilter = document.getElementById('btnFilter'),
            ipGeoToggle = document.getElementById('ipGeoToggle'),
            spinner = document.getElementById('spinner'),
            statusEl = document.getElementById('processStatus'),
            btnCountry = document.getElementById('btnCountry'),
            btnPing = document.getElementById('btnPing'),
            countryPopup = document.getElementById('countryPopup'),
            fileInput = document.getElementById('fileInput'),
            hiddenDownloadLink = document.getElementById('hiddenDownloadLink');

      let selectedCountry = 'OFF';

      // Popup Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ÑÑ‚Ñ€Ğ°Ğ½Ñ‹
      function initCountryPopup() {
        countryPopup.innerHTML = '';
        const container = document.createElement('div');
        container.className = 'search-container';
        const searchEl = document.createElement('input');
        searchEl.type = 'text';
        searchEl.placeholder = 'ĞŸĞ¾Ğ¸ÑĞºâ€¦';
        container.appendChild(searchEl);
        countryPopup.appendChild(container);
        const listEl = document.createElement('div');
        listEl.className = 'country-list';
        countryPopup.appendChild(listEl);
        searchEl.addEventListener('input', () => filterCountries(searchEl.value, listEl));
        filterCountries('', listEl);
      }
      function filterCountries(term, listEl) {
        const lower = term.toLowerCase();
        listEl.innerHTML = '';
        countries.forEach(c => {
          const matchName = !lower || c.name.toLowerCase().startsWith(lower);
          const matchFlag = term.includes(c.flag);
          if (matchName || matchFlag) {
            const item = document.createElement('div');
            item.className = 'country-item';
            item.innerHTML = `<span>${c.flag}</span><span>${c.name}</span>`;
            item.onclick = () => {
              selectedCountry = c.flag;
              btnCountry.textContent = c.flag;
              countryPopup.style.display = 'none';
            };
            listEl.appendChild(item);
          }
        });
      }
      btnCountry.addEventListener('click', e => {
        e.stopPropagation();
        countryPopup.style.display = countryPopup.style.display === 'block' ? 'none' : 'block';
        if (countryPopup.style.display === 'block') initCountryPopup();
      });
      document.addEventListener('click', () => {
        if (countryPopup.style.display === 'block') countryPopup.style.display = 'none';
      });
      countryPopup.addEventListener('click', e => e.stopPropagation());

      function setStatus(html, spinning) {
        statusEl.innerHTML = html;
        spinner.style.display = spinning ? 'inline-block' : 'none';
      }

      // Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ ping
      async function pingHost(host) {
        const controller = new AbortController();
        const timeoutMs = 5000;
        const start = performance.now();
        try {
          await Promise.race([
            fetch(`${location.protocol}//${host}`, { mode: 'no-cors', signal: controller.signal }),
            new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), timeoutMs))
          ]);
          const duration = Math.round(performance.now() - start);
          return { host, time: duration, status: `ğŸ”˜ ${duration}ms` };
        } catch {
          return { host, time: Infinity, status: 'âŒ Ñ‚Ğ°Ğ¹Ğ¼-Ğ°ÑƒÑ‚' };
        }
      }
      let pinging = false, controllers = [], resultsPing = [];
      async function pingAll() {
        pinging = true; controllers = []; resultsPing = [];
        const lines = inEl.value.split(/\r?\n/).filter(Boolean), total = lines.length;
        for (let i = 0; i < total; i++) {
          if (!pinging) break;
          let host;
          try { host = new URL(lines[i]).hostname; }
          catch { const m = lines[i].match(/\/\/([^\/:]+)/); host = m ? m[1] : lines[i]; }
          const res = await pingHost(host);
          resultsPing.push({ original: lines[i], ...res });
          setStatus(`Ğ¿Ğ¸Ğ½Ğ³â€¦ ${Math.round(resultsPing.length / total * 100)}%`, true);
          const sorted = resultsPing.slice().sort((a, b) => a.time - b.time);
          outEl.value = sorted.map(r => `${r.original} ${r.status}`).join('\n');
        }
        setStatus('Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ¾!', false); pinging = false;
      }
      function cancelPing() { pinging = false; controllers.forEach(c => c.abort()); setStatus('', false); }
      btnPing.onclick = () => pinging ? cancelPing() : pingAll();

      // ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº "Ğ¾Ğº" (Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€/GeoIP) Ñ Ğ´ĞµĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼ vmess-base64
      btnFilter.onclick = async () => {
        const rawLines = inEl.value.split(/\r?\n/).filter(Boolean);
        // Ğ”ĞµĞºĞ¾Ğ´Ğ¸Ñ€ÑƒĞµĞ¼ vmess://<Base64> Ğ² ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ğ¹ Ğ²Ğ¸Ğ´
        const lines = rawLines.map(line => {
          if (line.trim().startsWith('vmess://') && /^[A-Za-z0-9+/=]+$/.test(line.replace(/^vmess:\/\//, '').trim())) {
            return decodeVmessBase64(line);
          }
          return line;
        });

        // Ğ•ÑĞ»Ğ¸ Ğ² filterInput URL â€” ÑĞºĞ°Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑÑ‚Ñ‹
        if (filterInput.value.trim().match(/^https?:\/\//)) {
          const urls = filterInput.value.trim().split(/\s+/);
          const downloaded = [];
          setStatus('Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ°...<br>0%', true);
          for (let i = 0; i < urls.length; i++) {
            let txt = '';
            try {
              const resp = await fetch(urls[i]);
              if (!resp.ok) throw new Error();
              txt = await resp.text();
            } catch {
              const proxy = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(urls[i]);
              const resp2 = await fetch(proxy);
              txt = resp2.ok ? await resp2.text() : '';
            }
            // Ğ•ÑĞ»Ğ¸ Base64-ĞºĞ¾Ğ´, Ğ´ĞµĞºĞ¾Ğ´Ğ¸Ñ€ÑƒĞµĞ¼
            const b64 = txt.trim().replace(/\s+/g, '');
            if (/^[A-Za-z0-9+/=]+$/.test(b64) && b64.length % 4 === 0) {
              try { txt = atob(b64); } catch {}
            }
            downloaded.push(txt);
            setStatus(`Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ°...<br>${Math.round((i+1)/urls.length*100)}%`, true);
          }
          inEl.value = downloaded.join('\n');
          setStatus('Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ¾!', false);
          return;
        }

        // Ğ˜Ğ½Ğ°Ñ‡Ğµ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¸Ğ»Ğ¸ GeoIP
        btnFilter.disabled = true;
        setStatus('Ğ·Ğ°Ğ¿ÑƒÑĞº...<br>0%', true);
        const total = lines.length, results = [];

        if (ipGeoToggle.checked) {
          const seen = {};
          for (let i = 0; i < total; i++) {
            let host;
            try { host = new URL(lines[i]).hostname; }
            catch { const m = lines[i].match(/\/\/([^\/:]+)/); host = m ? m[1] : lines[i]; }
            if (!seen[host]) {
              try {
                const d = await (await fetch(buildGeoUrl(host))).json();
                const code = d.country_code || d.countryCode || d.code || d.geoplugin_countryCode || d.country;
                const name = d.country_name || d.countryName || d.geoplugin_countryName || d.country || host;
                seen[host] = code ? `${countryCodeToFlag(code)} ${name}` : host;
              } catch { seen[host] = host; }
            }
            results.push(`${lines[i].split('#')[0]}#${seen[host]}`);
            setStatus(`Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ°...<br>${Math.round((i+1)/total*100)}%`, true);
          }
        } else {
          for (let i = 0; i < total; i++) {
            let dec;
            try { dec = decodeURIComponent(lines[i]); } catch { dec = lines[i]; }
            const term = filterInput.value.trim().toLowerCase();
            const okText = !term || dec.toLowerCase().includes(term) || lines[i].toLowerCase().includes(term);
            const okCountry = selectedCountry === 'OFF' || dec.includes(selectedCountry) || lines[i].includes(selectedCountry);
            if (okText && okCountry) results.push(dec);
            setStatus(`Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ°...<br>${Math.round((i+1)/total*100)}%`, true);
          }
        }

        outEl.value = results.join('\n');
        setStatus('Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ¾!', false);
        btnFilter.disabled = false;
      };

      // json â†’ url
      document.getElementById('btnConvert').onclick = () => {
        let raw = inEl.value;
        const f = raw.indexOf('{'), l = raw.lastIndexOf('}');
        if (f !== -1 && l > f) raw = raw.slice(f, l + 1);
        if (!raw.trim()) { outEl.value = 'Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ json'; return; }
        const objs = extractAllJSON(raw), urls = [];
        objs.forEach(obj => {
          if (obj.configType === 'VLESS' && obj.customConfig && obj.password && obj.server) {
            buildURLFromLegacy(obj, urls); return;
          }
          if (obj.outboundBean) { buildURLsFromOutboundBean(obj, urls); return; }
          if (obj.custom_json && Array.isArray(obj.custom_json.outbounds)) {
            obj.custom_json.outbounds.forEach(o => buildURLFromOutbound(o, obj.remarks, urls)); return;
          }
          if (obj.server && obj.method && obj.password && obj.server_port) {
            const a = btoa(`${obj.method}:${obj.password}`).replace(/=+$/, '');
            let u = `ss://${a}@${obj.server}:${obj.server_port}`;
            if (obj.remarks) u += `#${encodeURIComponent(obj.remarks)}`;
            urls.push(u); return;
          }
          if (obj.configType === 'VLESS' && obj.security === 'reality' && obj.server) {
            const p = new URLSearchParams();
            p.set('encryption', obj.method || 'none');
            p.set('security', obj.security);
            if (obj.flow) p.set('flow', obj.flow);
            if (obj.alpn) p.set('alpn', Array.isArray(obj.alpn) ? obj.alpn.join(',') : obj.alpn);
            p.set('allowInsecure', obj.insecure ? '1' : '0');
            p.set('type', obj.network || '');
            if (obj.sni) p.set('sni', obj.sni);
            if (obj.fingerPrint) p.set('fp', obj.fingerPrint);
            if (obj.publicKey) p.set('pbk', obj.publicKey);
            if (obj.shortId) p.set('sid', obj.shortId);
            const t = obj.remarks ? encodeURIComponent(obj.remarks) : '';
            urls.push(`vless://${obj.password}@${obj.server}:${obj.serverPort}?${p.toString()}#${t}`);
            return;
          }
          (obj.outbounds || obj.fullConfig?.outbounds || []).forEach(o => buildURLFromOutbound(o, obj.remarks, urls));
        });
        outEl.value = urls.join('\n');
      };

      // url â†’ json
      document.getElementById('btnConvertBack').onclick = () => {
        if (!inEl.value.trim()) { outEl.value = 'Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ url'; return; }
        const lines = inEl.value.trim().split(/\r?\n/).filter(Boolean), arr = [];
        lines.forEach(line => {
          if (line.startsWith('ss://')) {
            const [main, hash] = line.slice(5).split('#');
            const tag = hash ? decodeURIComponent(hash) : '';
            const [auth, hp] = main.split('@');
            const [method, password] = atob(auth).split(':');
            const [address, portStr] = hp.split(':');
            const port = parseInt(portStr, 10);
            arr.push({
              protocol: 'shadowsocks', tag,
              settings: { servers: [{ address, port: isNaN(port) ? 0 : port, method, password }] },
              streamSettings: { network: 'tcp', security: 'none', tcpSettings: {} }
            });
          } else {
            try {
              const u = new URL(line), p = u.searchParams, proto = u.protocol.slice(0, -1);
              const tag = decodeURIComponent(u.hash.slice(1)) || proto;
              const typeParam = p.get('type') || '', headerType = p.get('headerType') || '';
              const h = p.get('host') || '', path = p.get('path') || '';
              const ssConf = {
                network: typeParam === 'xhttp' ? 'splithttp' : typeParam,
                security: p.get('security') || '', packetEncoding: p.get('packetEncoding') || '',
                tlsSettings: {
                  serverName: p.get('sni') || '', fingerprint: p.get('fp') || '',
                  allowInsecure: p.get('allowInsecure') === '1',
                  alpn: p.get('alpn') ? p.get('alpn').split(',') : []
                },
                realitySettings: { publicKey: p.get('pbk') || '', shortId: p.get('sid') || '', serverName: p.get('sni') || '' },
                kcpSettings: { seed: p.get('seed') || '' },
                grpcSettings: { serviceName: p.get('serviceName') || '' }
              };
              if (headerType === 'http' && ssConf.network === 'tcp')
                ssConf.tcpSettings = { header: { type: 'http', request: { headers: { Host: [h] }, path: [path] } } };
              else if (p.get('type') === 'http')
                ssConf.httpSettings = { host: [h], path };
              else if (ssConf.network === 'splithttp')
                ssConf.splithttpSettings = { host: h, path }, ssConf.xhttpSettings = { host: h, path };
              else if (ssConf.network === 'httpupgrade')
                ssConf.httpupgradeSettings = { host: h, path };
              else if (ssConf.network === 'ws' && h)
                ssConf.wsSettings = { headers: { Host: h }, path };
              if (proto === 'vless')
                arr.push({
                  protocol: 'vless', tag,
                  settings: { vnext: [{ address: u.hostname, port: +u.port, users: [{ id: u.username, encryption: p.get('encryption') || 'none', flow: p.get('flow') || '' }] }] },
                  streamSettings: ssConf
                });
              if (proto === 'vmess')
                arr.push({
                  protocol: 'vmess', tag,
                  settings: { vnext: [{ address: u.hostname, port: +u.port, users: [{ id: u.username, security: p.get('encryption') || 'auto' }] }] },
                  streamSettings: ssConf
                });
              if (proto === 'trojan')
                arr.push({
                  protocol: 'trojan', tag,
                  settings: { servers: [{ address: u.hostname, port: +u.port, password: decodeURIComponent(u.username) }] },
                  streamSettings: ssConf
                });
            } catch {}
          }
        });
        const conf = {
          dns: { fallbackStrategy: 'disabledIfAnyMatch', servers: [{ address: '8.8.8.8', queryStrategy: 'UseIP' }] },
          inbounds: [
            { listen: '0.0.0.0', port: 10805, protocol: 'socks', settings: { auth: 'noauth', udp: true }, tag: 'socks' },
            { listen: '0.0.0.0', port: 1080, protocol: 'http', settings: { allowTransparent: true }, tag: 'http' },
            { listen: '0.0.0.0', port: 10804, protocol: 'dokodemo-door', settings: { address: '0.0.0.0', network: 'tcp,udp', port: 10804 }, tag: 'dns-in' }
          ],
          log: { loglevel: 'warning' },
          outbounds: arr,
          policy: { levels: { '1': { connIdle: 30 } }, system: { statsOutboundDownlink: true, statsOutboundUplink: true } },
          routing: { domainStrategy: 'AsIs', rules: [{ inboundTag: ['dns-in'], outboundTag: 'dns-out', type: 'field' }] },
          stats: {}
        };
        outEl.value = JSON.stringify(conf, null, 2);
      };

      // Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ´Ğ»Ñ jsonâ†’url
      function buildURLFromLegacy(o, urls) {
        const p = new URLSearchParams();
        p.set('security', o.method || 'none');
        p.set('type', o.network || '');
        if (o.headerType) p.set('headerType', o.headerType);
        if (o.host) p.set('host', o.host);
        if (o.sni) p.set('sni', o.sni);
        if (o.path) p.set('path', o.path);
        if (o.alpn) p.set('alpn', Array.isArray(o.alpn) ? o.alpn.join(',') : o.alpn);
        if (o.pbk) p.set('pbk', o.pbk);
        if (o.sid) p.set('sid', o.sid);
        p.set('allowInsecure', o.insecure ? '1' : '0');
        if (o.seed) p.set('seed', o.seed);
        if (o.serviceName) p.set('serviceName', o.serviceName);
        const tag = encodeURIComponent(o.remarks || o.customConfig.name || '');
        const base = `vless://${o.password}@${o.server}:${o.serverPort}`;
        urls.push(`${base}?${p.toString()}#${tag}`);
      }
      function buildURLsFromOutboundBean(obj, urls) {
        buildURLFromOutbound(obj.outboundBean, obj.remarks, urls);
      }
      function buildURLFromOutbound(o, remarks, urls) {
        const proto = o.protocol, tag = encodeURIComponent(remarks || o.tag || proto), p = new URLSearchParams();
        let base = '';
        if (proto === 'shadowsocks') {
          (o.settings.servers || []).forEach(s => {
            const a = btoa(`${s.method}:${s.password}`).replace(/=+$/, '');
            urls.push(`ss://${a}@${s.address}:${s.port}#${tag}`);
          });
          return;
        }
        if (proto === 'vmess' || proto === 'vless') {
          const v = o.settings.vnext?.[0], u = v?.users?.[0];
          if (v && u) {
            base = `${proto}://${u.id}@${v.address}:${v.port}`;
            p.set('encryption', u.encryption || u.security || (proto === 'vmess' ? 'auto' : 'none'));
            if (u.flow) p.set('flow', u.flow);
          }
        }
        if (proto === 'trojan') {
          const s = o.settings.servers?.[0];
          if (s) base = `trojan://${encodeURIComponent(s.password)}@${s.address}:${s.port}`;
        }
        if (!base) return;
        const s = o.streamSettings || {}, tls = s.tlsSettings || {}, rel = s.realitySettings || {};
        if (s.security)       p.set('security', s.security);
        if (tls.allowInsecure) p.set('allowInsecure', '1');
        if (Array.isArray(tls.alpn)) p.set('alpn', tls.alpn.join(','));
        if (tls.serverName)    p.set('sni', tls.serverName);
        else if (rel.serverName) p.set('sni', rel.serverName);
        if (tls.fingerprint)   p.set('fp', tls.fingerprint);
        if (rel.publicKey)     p.set('pbk', rel.publicKey);
        if (rel.shortId)       p.set('sid', rel.shortId);
        if (s.grpcSettings?.serviceName) p.set('serviceName', s.grpcSettings.serviceName);
        if (s.kcpSettings?.seed)        p.set('seed', s.kcpSettings.seed);
        let net = s.network || (s.wsSettings ? 'ws' : s.httpupgradeSettings ? 'httpupgrade' : s.splithttpSettings ? 'splithttp' : s.httpSettings ? 'http' : 'tcp');
        if (net === 'splithttp') net = 'xhttp';
        p.set('type', net);
        let host = '', path = '';
        if (net === 'ws' && s.wsSettings) {
          host = s.wsSettings.headers?.Host || '';
          path = s.wsSettings.path || '';
        } else if (net === 'xhttp' && s.splithttpSettings) {
          host = s.splithttpSettings.host || '';
          path = s.splithttpSettings.path || '';
        } else if ((net === 'http' || net === 'xhttp' || net === 'httpupgrade') && s[net + 'Settings']) {
          const cfg = s[net + 'Settings'];
          host = Array.isArray(cfg.host) ? cfg.host[0] : cfg.host || '';
          path = cfg.path || '';
        } else if (net === 'tcp' && s.tcpSettings?.header?.type === 'http') {
          const rq = s.tcpSettings.header.request;
          host = (rq.headers?.Host || [''])[0] || '';
          path = (rq.path || [''])[0] || '';
          p.set('headerType', 'http');
        }
        if (host) p.set('host', host);
        if (path) p.set('path', path);
        urls.push(`${base}?${p.toString()}#${tag}`);
      }

      // Base64 â†” Ñ‚ĞµĞºÑÑ‚
      document.getElementById('btnTextBase64').onclick = () => {
        const t = inEl.value.trim();
        if (!t) { outEl.value = 'Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ Ñ‚ĞµĞºÑÑ‚'; return; }
        try { outEl.value = decodeURIComponent(escape(atob(t))); }
        catch { outEl.value = btoa(unescape(encodeURIComponent(t))); }
      };

      // ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ
      document.getElementById('btnCopy').onclick = () => {
        const text = outEl.value;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text).then(() => alert('Ğ¡ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾!')).catch(fallbackCopy);
        } else {
          fallbackCopy();
        }
        function fallbackCopy() {
          const ta = document.createElement('textarea');
          ta.value = text; ta.setAttribute('wrap','off');
          ta.style.position='absolute'; ta.style.left='-9999px';
          document.body.appendChild(ta);
          ta.select(); ta.setSelectionRange(0, ta.value.length);
          document.execCommand('copy');
          document.body.removeChild(ta);
          alert('Ğ¡ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾!');
        }
      };

      // Ğ¡ĞºĞ°Ñ‡Ğ°Ñ‚ÑŒ
      document.getElementById('btnDownload').onclick = () => {
        const d = outEl.value.trim(); if (!d) return alert('ĞĞµÑ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…');
        hiddenDownloadLink.href = URL.createObjectURL(new Blob([d], { type: 'text/plain' }));
        hiddenDownloadLink.download = 'result.txt'; hiddenDownloadLink.click();
        setTimeout(() => URL.revokeObjectURL(hiddenDownloadLink.href), 1000);
      };

      // Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»
      document.getElementById('btnLoadFile').onclick = () => fileInput.click();
      fileInput.onchange = e => {
        const fr = new FileReader();
        fr.onload = () => inEl.value = fr.result;
        fr.readAsText(e.target.files[0]);
      };

      // ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¾Ğ±Ğ° Ğ¿Ğ¾Ğ»Ñ
      document.getElementById('btnClear').onclick = () => {
        inEl.value = '';
        outEl.value = '';
      };
    });
  </script>
</body>
</html>